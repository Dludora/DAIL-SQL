SELECT MAX(`Percent (%) Eligible Free (K-12)`) AS Highest_Free_Rate FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.County = 'Alameda' GROUP BY frpm.CDSCode;
SELECT `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)` AS Eligible_Free_Rate FROM frpm JOIN schools USING (CDSCode) WHERE `District Type` = 'Continuation' ORDER BY Eligible_Free_Rate ASC LIMIT 3;
SELECT DISTINCT schools.Zip FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.County = 'Fresno' AND frpm.`Charter School (Y/N)` = 1;
SELECT schools.MailStreet FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE `FRPM Count (K-12)` = ( SELECT MAX(`FRPM Count (K-12)`) FROM frpm ) LIMIT 1;
SELECT schools.Phone FROM schools INNER JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE frpm.`Charter School (Y/N)` = 1 AND schools.OpenDate > '2000-01-01';
SELECT COUNT(*) FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE AvgScrMath > 400 AND Virtual = 'F';
SELECT sch.School AS SchoolName, sat.NumTstTakr FROM satscores sat INNER JOIN schools sch ON sat.cds = sch.CDSCode WHERE sat.NumTstTakr > 500 AND sch.Magnet = 1;
SELECT schools.Phone FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.NumTstTakr > 1500 ORDER BY satscores.NumTstTakr DESC LIMIT 1;
SELECT s.NumTstTakr FROM frpm f JOIN satscores s ON f.CDSCode = s.cds WHERE f.`FRPM Count (K-12)` = ( SELECT MAX(f2.`FRPM Count (K-12)`) FROM frpm f2 ) LIMIT 1;
SELECT COUNT(*) FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE AvgScrMath > 560 AND Charter IS NOT NULL;
SELECT COALESCE(frpm.`FRPM Count (Ages 5-17)`, 0) AS FRPM_Count FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.CDSCode = ( SELECT cds FROM satscores WHERE rtype = 'School' ORDER BY AvgScrRead DESC LIMIT 1 );
SELECT s.CDSCode FROM frpm f INNER JOIN schools s ON f.CDSCode = s.CDSCode WHERE (f.`Enrollment (K-12)` + f.`Enrollment (Ages 5-17)`) > 500;
SELECT ROUND((`Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`) * 100, 2) AS Eligible_Free_Rate_Percentage, s.CDSCode, s.School_Name FROM ( SELECT frpm.*, schools.* FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode ) AS s JOIN satscores ON s.CDSCode = satscores.cds WHERE (satscores.NumGE1500 / satscores.NumTstTakr) > 0.3 AND `Enrollment (Ages 5-17)` != 0 AND `Free Meal Count (Ages 5-17)` != 0 ORDER BY Eligible_Free_Rate_Percentage DESC LIMIT 1;
SELECT schools.Phone FROM satscores JOIN frpm ON satscores.cds = frpm.CDSCode JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.rtype = 'S' -- Assuming we want only school-level data ORDER BY (satscores.NumGE1500 / NULLIF(satscores.NumTstTakr, 0)) DESC LIMIT 3;
SELECT s.NCESSchool AS "NCES School ID", f.`Enrollment (Ages 5-17)` AS "Enrollment Age 5-17" FROM frpm AS f JOIN schools AS s ON f.CDSCode = s.CDSCode ORDER BY `Enrollment (Ages 5-17)` DESC LIMIT 5;
SELECT dname AS District, AVG(AvgScrRead) AS AverageReadingScore FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE StatusType = 'Active' GROUP BY dname ORDER BY AverageReadingScore DESC LIMIT 1;
SELECT COUNT(*) FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.County = 'Alameda' AND satscores.NumTstTakr < 100;
SELECT satscores.AvgScrWrite AS `Average Writing Score`, schools.CharterNum AS `Charter School Number` FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.AvgScrWrite > 499 ORDER BY satscores.AvgScrWrite DESC;
SELECT COUNT(*) AS NumberOfSchools FROM satscores INNER JOIN schools ON satscores.cds = schools.CDSCode INNER JOIN frpm ON satscores.cds = frpm.CDSCode WHERE schools.County = 'Fresno' AND satscores.NumTstTakr <= 250 AND frpm.Charter_Funding_Type = 'Direct';
SELECT schools.Phone FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.AvgScrMath = ( SELECT MAX(satscores.AvgScrMath) FROM satscores WHERE satscores.AvgScrMath IS NOT NULL ) LIMIT 1;
SELECT COUNT(*) FROM schools s INNER JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.County = 'Amador' AND f.`Low Grade` = 9 AND f.`High Grade` = 12;
SELECT COUNT(*) FROM frpm WHERE `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)` < 700 AND EXISTS ( SELECT 1 FROM schools WHERE CDSCode = frpm.CDSCode AND County = 'Los Angeles' );
SELECT s.School AS SchoolName, s.NumTstTakr AS NumberOfTestTakers FROM satscores s JOIN schools sc ON s.cds = sc.CDSCode WHERE sc.County = 'Contra Costa' ORDER BY s.NumTstTakr DESC LIMIT 1;
SELECT s.School AS SchoolName, CONCAT(s.Street, ', ', s.City, ' ', s.State, ' ', s.Zip) AS FullStreetAddress FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode WHERE (f.`Enrollment (K-12)` - f.`Enrollment (Ages 5-17)`) > 30;
SELECT schools.School AS SchoolName, CASE WHEN frpm."Enrollment (K-12)" = 0 THEN 0 ELSE (frpm."Free Meal Count (K-12)" / frpm."Enrollment (K-12)") * 100 END AS PercentEligibleFree, CASE WHEN satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite = 0 THEN 0 ELSE (satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite) / 3 END AS AverageSATScore FROM schools JOIN frpm ON schools.CDSCode = frpm.CDSCode JOIN satscores ON schools.CDSCode = satscores.cds WHERE (frpm."Free Meal Count (K-12)" / frpm."Enrollment (K-12)") * 100 > 0.1 AND ( satscores.AvgScrRead + satscores.AvgScrMath + satscores.AvgScrWrite ) / 3 >= 1500 ORDER BY schools.School;
SELECT s.FundingType AS Funding_Type, s.School AS School_Name, AVG(ss.AvgScrMath) AS Average_Math_Score FROM satscores ss JOIN schools s ON ss.cds = s.CDSCode WHERE s.County = 'Riverside' GROUP BY s.FundingType, s.School HAVING AVG(ss.AvgScrMath) > 400 ORDER BY Average_Math_Score DESC;
SELECT DISTINCT schools.CDSCode, schools.School AS SchoolName, schools.Street AS StreetAddress, schools.City AS City, schools.State AS State, schools.Zip AS ZIP_Code FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE `FRPM Count (Ages 5-17)` > 800 AND schools.District IN ( SELECT DISTINCT dname FROM satscores WHERE rtype = 'High School' ) ORDER BY schools.School;
SELECT schools.School AS SchoolName, schools.Phone AS CommunicationNumber, AVG(satscores.AvgScrWrite) AS AverageWritingScore FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE (schools.OpenDate > '1991-01-01' OR schools.ClosedDate < '2000-01-01') GROUP BY schools.School, schools.Phone;
WITH cte AS ( SELECT frpm."Enrollment (K-12)" - frpm."Enrollment (Ages 5-17)" AS difference, s.School, s.DOCType FROM frpm JOIN schools s ON frpm.CDSCode = s.CDSCode WHERE s."Charter Funding Type" = 'Local' ) SELECT cte.School, cte.DOCType FROM cte WHERE cte.difference > ( SELECT AVG(difference) AS avg_diff FROM ( SELECT frpm."Enrollment (K-12)" - frpm."Enrollment (Ages 5-17)" AS difference FROM frpm JOIN schools s ON frpm.CDSCode = s.CDSCode WHERE s."Charter Funding Type" = 'Local' ) subquery )
SELECT schools.OpenDate FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode ORDER BY `Enrollment (K-12)` DESC LIMIT 1;
SELECT s.City AS City, f.`Enrollment (K-12)` AS `Enrollment (K-12)` FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode ORDER BY `Enrollment (K-12)` ASC LIMIT 5;
SELECT f.CDSCode, sch.School Name AS SchoolName, CASE WHEN RANK() OVER (ORDER BY `Enrollment (K-12)` DESC) IN (10, 11) THEN (`Free Meal Count (K-12)` / `Enrollment (K-12)`) ELSE NULL END AS Eligible_Free_Rate FROM frpm f JOIN schools sch ON f.CDSCode = sch.CDSCode ORDER BY `Enrollment (K-12)` DESC;
SELECT s.School, f.`FRPM Count (K-12)`, f.`Enrollment (K-12)`, (f.`FRPM Count (K-12)` / f.`Enrollment (K-12)`) AS eligible_rate FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode LEFT JOIN satscores sat ON f.CDSCode = sat.cds WHERE s.District_Code = 66 -- 假设District Code对应所有权代码66 ORDER BY `FRPM Count (K-12)` DESC LIMIT 5;
SELECT DISTINCT s.Website AS School_Website, s.School AS School_Name FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE f.`Free Meal Count (Ages 5-17)` BETWEEN 1900 AND 2000;
SELECT `Free Meal Count (Ages 5-17)` AS FreeMealCount, `Enrollment (Ages 5-17)` AS EnrollmentAge5_17, (`Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`) AS FreeRate FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE AdmFName1 = 'Kacey' AND AdmLName1 = 'Gibson';
SELECT schools.AdmEmail1, schools.AdmEmail2, schools.AdmEmail3 FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE frpm.`Charter School (Y/N)` = 1 AND frpm.`Enrollment (K-12)` = ( SELECT MIN(frpm.`Enrollment (K-12)`) FROM frpm WHERE `Charter School (Y/N)` = 1 )
SELECT schools.School AS SchoolName, COALESCE(schools.AdmFName1, '') AS AdmFirstName1, COALESCE(schools.AdmLName1, '') AS AdmLastName1, COALESCE(schools.AdmFName2, '') AS AdmFirstName2, COALESCE(schools.AdmLName2, '') AS AdmLastName2, COALESCE(schools.AdmFName3, '') AS AdmFirstName3, COALESCE(schools.AdmLName3, '') AS AdmLastName3 FROM satscores JOIN frpm ON satscores.cds = frpm.CDSCode JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.NumGE1500 > 0 GROUP BY satscores.cds ORDER BY NumGE1500 DESC LIMIT 1;
SELECT s.Street AS Street, s.City AS City, s.State AS State, s.Zip AS Zip FROM satscores sc JOIN schools s ON sc.cds = s.CDSCode WHERE sc.NumTstTakr != 0 AND sc.NumGE1500 != 0 ORDER BY (sc.NumGE1500 / sc.NumTstTakr) ASC LIMIT 1;
SELECT schools.School, schools.Website FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.County = 'Los Angeles' AND satscores.NumTstTakr BETWEEN 2000 AND 3000;
SELECT AVG(NumTstTakr) AS AverageTestTakers FROM satscores JOIN schools USING (cds) WHERE schools.County = 'Fresno' AND OpenDate BETWEEN '1980-01-01' AND '1980-12-31';
SELECT schools.Phone AS Telephone_Number FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.dname = 'Fresno Unified' ORDER BY satscores.AvgScrRead ASC LIMIT 1;
WITH VirtualSchoolRanks AS ( SELECT s.CDSCode, s.School AS Virtual_School_Name, s.County, sat.AvgScrRead, RANK() OVER (PARTITION BY s.County ORDER BY sat.AvgScrRead DESC) AS CountyRank FROM schools s JOIN satscores sat ON s.CDSCode = sat.cds WHERE s.Virtual = 'F' AND sat.AvgScrRead IS NOT NULL ) SELECT Virtual_School_Name, County, AvgScrRead FROM VirtualSchoolRanks WHERE CountyRank <= 5 ORDER BY County, AvgScrRead DESC;
SELECT frpm.`Educational Option Type` FROM satscores JOIN schools ON satscores.cds = schools.CDSCode JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE (satscores.rtype = 'S' AND satscores.AvgScrMath = ( SELECT MAX(satscores.AvgScrMath) FROM satscores WHERE rtype = 'S' ));
SELECT AvgScrMath AS Average_Math_Score, County AS County_Location FROM ( SELECT s.cds, s.AvgScrMath, sch.County, (s.AvgScrRead + s.AvgScrMath + s.AvgScrWrite) AS Total_Average_Score FROM satscores s INNER JOIN schools sch ON s.cds = sch.CDSCode ) subquery ORDER BY Total_Average_Score ASC LIMIT 1;
SELECT AVG(s.AvgScrWrite) AS AverageWritingScore, sch.City FROM satscores s JOIN schools sch ON s.cds = sch.CDSCode WHERE s.rtype = 'S' -- Only consider school-level records GROUP BY s.cds ORDER BY NumGE1500 DESC -- Order by number of students scoring >=1500 LIMIT 1; -- Get the top result
SELECT schools.CDSCode AS SchoolID, schools.School AS SchoolName, AVG(satscores.AvgScrWrite) AS AverageWritingScore FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE (schools.AdmFName1 = 'Ricci' AND schools.AdmLName1 = 'Ulrich') OR (schools.AdmFName2 = 'Ricci' AND schools.AdmLName2 = 'Ulrich') OR (schools.AdmFName3 = 'Ricci' AND schools.AdmLName3 = 'Ulrich') GROUP BY schools.CDSCode;
SELECT s.School, s.County, s.District, f.`Enrollment (K-12)` AS NumberOfStudents FROM frpm f JOIN schools s ON f.CDSCode = s.CDSCode WHERE s.DOC = 31 ORDER BY f.`Enrollment (K-12)` DESC;
SELECT ROUND(COUNT(schools.CDSCode) / 12, 2) AS Monthly_Average FROM schools WHERE schools.County = 'Alameda' AND schools.DOCType = '52' AND YEAR(schools.OpenDate) = 1980;
SELECT ROUND( (COUNT(CASE WHEN DOC = '54' THEN 1 END) / COUNT(CASE WHEN DOC = '52' THEN 1 END)), 2 ) AS Ratio FROM schools WHERE County = 'Orange';
SELECT `County` AS county_name, School AS school_name, ClosedDate AS closure_date, RANK() OVER (ORDER BY COUNT(*) DESC) AS rank FROM schools WHERE StatusType = 'Closed' GROUP BY `County`, School, ClosedDate;
SELECT schools.MailStreet AS Postal_Street_Address, schools.School AS School_Name FROM satscores JOIN schools ON satscores.cds = schools.CDSCode ORDER BY AvgScrMath DESC LIMIT 1 OFFSET 6;
SELECT s.MailStreet, sch.SchoolName FROM satscores AS s LEFT JOIN schools AS sch ON s.cds = sch.CDSCode WHERE s.AvgScrRead = ( SELECT COALESCE(MIN(AvgScrRead), 0) FROM satscores );
SELECT COUNT(DISTINCT s.cds) AS TotalSchools FROM satscores s JOIN schools sc ON s.cds = sc.CDSCode WHERE sc.MailCity = 'Lakeport' AND (s.AvgScrRead + s.AvgScrMath + s.AvgScrWrite) >= 1500;
SELECT SUM(enroll12) AS TotalTestTakers FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE schools.MailCity = 'Fresno';
SELECT School, MailZip FROM schools WHERE AdmLName1 = 'Atoian' AND AdmFName1 = 'Avetik';
SELECT (colusa_count / humboldt_count) AS colusa_to_humboldt_ratio FROM ( SELECT COUNT(CASE WHEN County = 'Colusa' THEN 1 END) AS colusa_count, COUNT(CASE WHEN County = 'Humboldt' THEN 1 END) AS humboldt_count FROM schools WHERE MailState = 'CA' ) AS county_counts;
SELECT COUNT(*) FROM schools WHERE MailState = 'California' AND MailCity = 'San Joaquin' AND StatusType = 'Active';
SELECT schools.Phone, schools.Ext FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE (SELECT COUNT(*) FROM satscores WHERE AvgScrWrite >= satscores.AvgScrWrite) <= 333 ORDER BY satscores.AvgScrWrite DESC LIMIT 1;
SELECT School, Phone, Ext FROM schools WHERE Zip = '95203-3704';
SELECT DISTINCT schools.Website FROM schools WHERE (AdmFName1 || ' ' || AdmLName1 = 'Mike Larson' OR AdmFName2 || ' ' || AdmLName2 = 'Mike Larson' OR AdmFName3 || ' ' || AdmLName3 = 'Mike Larson') OR (AdmFName1 || ' ' || AdmLName1 = 'Dante Alvarez' OR AdmFName2 || ' ' || AdmLName2 = 'Dante Alvarez' OR AdmFName3 || ' ' || AdmLName3 = 'Dante Alvarez');
SELECT COALESCE(Website, '') AS Website FROM schools WHERE Virtual = 'P' AND Charter = 1 AND County = 'San Joaquin';
SELECT COUNT(*) FROM schools WHERE Charter = 1 AND City = 'Hickman' AND DOC = 52;
SELECT COUNT(DISTINCT s.CDSCode) AS TotalNonCharteredSchools FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.County = 'Los Angeles' AND s.Charter = 0 AND (f.`Free Meal Count (K-12)` * 100 / f.`Enrollment (K-12)`) < 0.18 AND f.`Enrollment (K-12)` > 0;
SELECT School, City, CONCAT(AdmFName1, ' ', AdmLName1) AS AdministratorFullName FROM schools WHERE Charter = 1 AND CharterNum = '00D2' UNION SELECT School, City, CONCAT(AdmFName2, ' ', AdmLName2) AS AdministratorFullName FROM schools WHERE Charter = 1 AND CharterNum = '00D2' UNION SELECT School, City, CONCAT(AdmFName3, ' ', AdmLName3) AS AdministratorFullName FROM schools WHERE Charter = 1 AND CharterNum = '00D2';
SELECT COUNT(*) FROM schools WHERE `MailCity` = 'Hickman' AND CharterNum = '00D4';
SELECT (COUNT(CASE WHEN frpm.Charter_Funding_Type = 'Local' THEN 1 END) / COUNT(*) ) * 100 AS Local_Charter_Schools_Percentage FROM schools LEFT JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.IsCharter = 1 AND schools.County = 'Santa Clara';
SELECT COUNT(DISTINCT CDSCode) AS NumberOfDirectlyFundedSchools FROM schools WHERE FundingType = 'Directly Funded' AND OpenDate BETWEEN '2000-01-01' AND '2005-12-31' AND County = 'Stanislaus';
SELECT COUNT(DISTINCT CDSCode) FROM schools WHERE ClosedDate = '1989-12-31' AND StatusType = 'CLOSED' AND County = 'San Francisco';
SELECT County, COUNT(*) AS ClosureCount FROM schools WHERE ClosedDate BETWEEN '1980-01-01' AND '1989-12-31' AND SOC = '11' GROUP BY County ORDER BY ClosureCount DESC;
SELECT NCESDist FROM schools WHERE SOC = '31';
SELECT COUNT(*) AS Total, CASE WHEN StatusType = 'Active' THEN COUNT(*) ELSE 0 END AS ActiveCount, CASE WHEN StatusType = 'Closed' THEN COUNT(*) ELSE 0 END AS ClosedCount FROM schools WHERE County = 'Alpine' GROUP BY StatusType;
SELECT frpm.`District Code` FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.City = 'Fresno' AND schools.Magnet = 0;
SELECT frpm.`Enrollment (Ages 5-17)` AS Total_Students FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.EdOpsCode = 'SSS' AND frpm.`Academic Year` = '2014-15';
SELECT `Free Meal Count (Ages 5-17)` FROM frpm WHERE CDSCode IN ( SELECT CDSCode FROM schools WHERE School = 'Youth Authority School' AND MailStreet = 'PO Box 1040' );
SELECT `Low Grade` FROM schools AS s JOIN frpm AS f ON s.CDSCode = f.CDSCode WHERE s.NCESDist = '0613360' AND s.EdOpsCode = 'SPECON';
SELECT s.`Educational Option Type` AS Educational_Level, s.School Name AS School_Name FROM frpm f LEFT JOIN schools s ON f.CDSCode = s.CDSCode WHERE f.`NSLP Provision Status` = '2' AND f.`County Code` = '37';
SELECT DISTINCT schools.City FROM schools JOIN frpm ON schools.CDSCode = frpm.CDSCode WHERE schools.EILCode = 'HS' AND frpm.`NSLP Provision Status` = 2 AND frpm.`Low Grade` = '9' AND frpm.`High Grade` = '12' AND schools.County = 'Merced';
SELECT schools.School Name AS SchoolName, schools.County Name AS CountyName, (frpm.`FRPM Count (Ages 5-17)` / frpm.`Enrollment (Ages 5-17)`) * 100 AS `Percent (%) Eligible FRPM (Ages 5-17)` FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.County = 'Los Angeles' AND frpm.`Low Grade` = 'K' AND frpm.`High Grade` = '9';
SELECT COUNT(*) AS count, CASE WHEN `Low Grade` = 'K' AND `High Grade` = '12' THEN 'K-12' WHEN `Low Grade` = '5' AND `High Grade` = '17' THEN 'Ages 5-17' ELSE 'Other' END AS span_type FROM frpm JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.County = 'Adelanto' GROUP BY span_type ORDER BY count DESC;
SELECT County AS CountyName, COUNT(*) AS NumberOfSchoolsWithoutPhysicalBuilding FROM schools WHERE Virtual = 'F' GROUP BY County;
SELECT School, Latitude AS Max_Latitude, `School Type` AS School_Type FROM schools WHERE Latitude = (SELECT MAX(Latitude) FROM schools) LIMIT 1;
SELECT City, `Low Grade`, School FROM schools WHERE State = 'CA' ORDER BY Latitude ASC LIMIT 1;
SELECT (f.HighGrade - f.LowGrade) AS GradeSpan, s.Longitude FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE ABS(s.Longitude) = ( SELECT MAX(ABS(Longitude)) FROM schools );
SELECT s.City AS City, COUNT(s.CDSCode) AS NumberOfSchools FROM schools s JOIN frpm f ON s.CDSCode = f.CDSCode WHERE s.Magnet = 1 AND s.LowGrade = 'K' AND s.HighGrade = '8' AND f.NSLPProvisionStatus = 'Multiple Provision Types' GROUP BY s.City HAVING COUNT(s.CDSCode) > 0;
SELECT AdmFName1, AdmLName1 AS FirstName, District FROM schools GROUP BY AdmFName1, AdmLName1 ORDER BY COUNT(*) DESC LIMIT 2;
SELECT MAX(CAST(`Percent (%) Eligible Free (K-12)` AS INTEGER)) AS `Percent (%) Eligible Free (K-12)`, frpm.`District Code` FROM frpm LEFT JOIN schools ON frpm.CDSCode = schools.CDSCode WHERE schools.AdmFName1 = 'Alusine' OR schools.AdmFName2 = 'Alusine' OR schools.AdmFName3 = 'Alusine' GROUP BY frpm.`District Code`;
SELECT AdmLName1 AS Administrator_Last_Name, District, County, School FROM schools s1 JOIN schools s2 ON s1.CDSCode = s2.CDSCode WHERE s2.CharterNum = '40';
SELECT AdmEmail1, AdmEmail2, AdmEmail3 FROM schools WHERE County = 'San Bernardino' AND District = 'San Bernardino City Unified' AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND SOCType = 62 AND DOCType = 54;
SELECT schools.AdmEmail1, schools.AdmEmail2, schools.AdmEmail3, schools.School as SchoolName FROM satscores JOIN schools ON satscores.cds = schools.CDSCode WHERE satscores.rtype = 'HS' GROUP BY satscores.cds, satscores.rtype ORDER BY NumGE1500 DESC LIMIT 1;
SELECT COUNT(DISTINCT account.account_id) FROM account JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id JOIN district ON client.district_id = district.district_id WHERE disp.type = 'POPLATEK PO OBRATU' AND district.A3 = 'East Bohemia';
SELECT COUNT(DISTINCT a.account_id) AS eligible_accounts_count FROM account a INNER JOIN district d ON a.district_id = d.district_id INNER JOIN loan l ON a.account_id = l.account_id WHERE d.A3 = 'Prague';
SELECT CASE WHEN AVG(A12) > AVG(A13) THEN '1995' ELSE '1996' END AS Year, ROUND((AVG(CASE WHEN A12 IS NOT NULL THEN A12 END) + AVG(CASE WHEN A13 IS NOT NULL THEN A13 END)) / 2, 2) AS `Average Unemployment Rate` FROM district WHERE A12 IS NOT NULL AND A13 IS NOT NULL;
SELECT COUNT(DISTINCT d.district_id) AS district_count FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'F' GROUP BY d.district_id HAVING AVG(d.A11) > 6000 AND AVG(d.A11) < 10000;
SELECT COUNT(DISTINCT c.client_id) AS male_customers_count FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'M' AND d.A3 = 'North Bohemia' AND d.A11 > 8000;
SELECT a.account_id, d.A11 AS salary FROM account a JOIN client c ON a.client_id = c.client_id JOIN district d ON c.district_id = d.district_id;
WITH max_birth AS ( SELECT MAX(birth_date) as max_b FROM client ), max_salary AS ( SELECT MAX(A11) as max_s FROM district ) SELECT a.account_id FROM account a JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id JOIN district dist ON c.district_id = dist.district_id WHERE c.birth_date = (SELECT max_b FROM max_birth) AND dist.A11 = (SELECT max_s FROM max_salary);
SELECT COUNT(DISTINCT c.client_id) AS weekly_statement_owner_count FROM card c JOIN disp d ON c.disp_id = d.disp_id JOIN client cl ON d.client_id = cl.client_id WHERE c.type = 'POPLATEK TYDNE';
SELECT disp.client_id AS id_number FROM disp WHERE disp.type = 'POPLATEK PO OBRATU';
SELECT loan_id, account_id FROM loan WHERE strftime('%Y', date) = '1997' GROUP BY account_id HAVING MIN(amount) = ( SELECT MIN(amount) FROM loan WHERE strftime('%Y', date) = '1997' ) ORDER BY amount;
SELECT a.account_id, MAX(l.amount) AS highest_approved_amount FROM account a JOIN loan l ON a.account_id = l.account_id WHERE l.duration > 12 AND a.date BETWEEN '1993-01-01' AND '1993-12-31' GROUP BY a.account_id ORDER BY highest_approved_amount DESC;
SELECT COUNT(*) AS female_customers_count FROM client JOIN district ON client.district_id = district.district_id WHERE client.gender = 'F' AND client.birth_date < '1950-01-01' AND district.A2 = 'Sokolov';
SELECT t.account_id, MIN(t.date) AS earliest_date FROM trans t WHERE t.date >= '1995-01-01' AND t.date <= '1995-12-31' GROUP BY t.account_id;
SELECT DISTINCT a.account_id, t.balance FROM account AS a JOIN trans AS t ON a.account_id = t.account_id WHERE a.date < '1997-01-01' AND t.balance > 3000 ORDER BY t.balance DESC;
SELECT c.client_id FROM card AS ca INNER JOIN disp AS d ON ca.disp_id = d.disp_id WHERE ca.issued = '1994-03-03';
SELECT account.date AS account_opened_date FROM trans JOIN account ON trans.account_id = account.account_id WHERE trans.amount = 840 AND trans.date = '1998-10-14';
SELECT loan.account_id, account.district_id FROM loan JOIN account ON loan.account_id = account.account_id WHERE loan.date = '1994-08-25';
SELECT MAX(amount) AS max_amount FROM trans JOIN account USING (account_id) JOIN disp USING (account_id, client_id) JOIN card ON disp.disp_id = card.disp_id WHERE card.issued = '1996-10-21';
SELECT c.gender FROM client c JOIN district d ON c.district_id = d.district_id WHERE d.A11 = ( SELECT MAX(A11) FROM district ) ORDER BY c.birth_date ASC LIMIT 1;
SELECT t.amount FROM trans AS t INNER JOIN account AS a ON t.account_id = a.account_id INNER JOIN loan AS l ON a.account_id = l.account_id WHERE l.account_id = ( SELECT MAX(amount) FROM loan WHERE account_id = a.account_id ) ORDER BY t.date ASC LIMIT 1;
SELECT COUNT(DISTINCT c.client_id) AS female_clients_jesenik FROM client c LEFT JOIN disp d ON c.client_id = d.client_id LEFT JOIN account a ON d.account_id = a.account_id LEFT JOIN district dist ON a.district_id = dist.district_id WHERE dist.A2 = 'Jesenik' AND c.gender = 'F';
SELECT disp.disp_id FROM trans INNER JOIN disp ON trans.account_id = disp.account_id WHERE trans.date = '1998-09-02' AND trans.amount = 5100;
SELECT COUNT(*) AS account_count FROM account JOIN district ON account.district_id = district.district_id WHERE DATEPART(year, date) = 1996 AND A2 = 'Litomerice';
SELECT DISTINCT d.A2 AS district_name FROM client c JOIN disp dp ON c.client_id = dp.client_id JOIN account acc ON dp.account_id = acc.account_id JOIN district d ON acc.district_id = d.district_id WHERE c.gender = 'F' AND c.birth_date = '1976-01-29';
SELECT c.birth_date FROM loan l JOIN account a ON l.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE l.amount = 98832 AND l.date = '1996-01-03';
SELECT MIN(a.account_id) AS first_account_id FROM account a JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id JOIN district dist ON c.district_id = dist.district_id WHERE dist.A3 = 'Prague';
SELECT (COUNT(CASE WHEN gender = 'M' THEN 1 END) / COUNT(*) * 100) AS male_client_percentage FROM client WHERE district_id IN ( SELECT district_id FROM district WHERE A3 = 'South Bohemia' ORDER BY A4 DESC LIMIT 1 );
WITH first_loan AS ( SELECT account_id FROM loan WHERE status = 'approved' AND date <= '1993-07-05' ORDER BY date ASC, loan_id ASC LIMIT 1 )
SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) / SUM(amount)) * 100 AS paid_percentage, SUM(amount) AS total_loan_amount FROM loan;
SELECT ROUND( ( SUM(amount) / ( SELECT SUM(amount) FROM loan WHERE amount < 100000 ) ) * 100, 2 ) AS percentage FROM loan WHERE amount < 100000 AND status = 'C';
SELECT DISTINCT a.account_id, d.A2 AS district_name, d.A3 AS region FROM account a JOIN district d ON a.district_id = d.district_id WHERE a.date BETWEEN '1993-01-01' AND '1993-12-31' AND ( EXISTS ( SELECT 1 FROM loan l JOIN trans t ON l.account_id = t.account_id WHERE l.account_id = a.account_id AND l.date > t.date AND t.date BETWEEN '1993-01-01' AND '1993-12-31' ) OR EXISTS ( SELECT 1 FROM `order` o JOIN trans t ON o.account_id = t.account_id WHERE o.account_id = a.account_id AND o.date > t.date AND t.date BETWEEN '1993-01-01' AND '1993-12-31' ) );
SELECT account.account_id, account.frequency, COUNT(*) AS frequency_count FROM account JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id JOIN district ON client.district_id = district.district_id WHERE district.A2 = 'East Bohemia' AND client.birth_date BETWEEN '1995-01-01' AND '2000-12-31' GROUP BY account.account_id, account.frequency;
SELECT account.account_id, account.date FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Prachatice';
SELECT A2 AS district, A3 AS region FROM district WHERE district_id = ( SELECT account.district_id FROM loan JOIN account ON loan.account_id = account.account_id WHERE loan.loan_id = '4990' );
SELECT loan.account_id, district.A2 AS district_name, district.A3 AS region_name FROM loan INNER JOIN account ON loan.account_id = account.account_id INNER JOIN district ON account.district_id = district.district_id WHERE loan.amount > 300000;
SELECT loan.loan_id, district.A3 AS region, district.A11 AS average_salary FROM loan JOIN account ON loan.account_id = account.account_id JOIN district ON account.district_id = district.district_id WHERE loan.duration = 60;
SELECT d.district_id, ((d.A13 - d.A12) / NULLIF(d.A12, 0)) * 100 AS unemployment_rate_increase_percent FROM loan l JOIN account a ON l.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE l.status = 'D' GROUP BY d.district_id HAVING d.A12 IS NOT NULL AND d.A13 IS NOT NULL;
SELECT (COUNT(*) FILTER (WHERE district_id = (SELECT district_id FROM district WHERE A2 = 'Decin')) / COUNT(*)) * 100 AS percentage FROM account WHERE date LIKE '1993-%';
SELECT DISTINCT account_id FROM account WHERE frequency = 'POPLATEK MESICNE';
SELECT d.district_id, d.A2 AS district_name, COUNT(c.client_id) AS female_account_holders FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'F' GROUP BY d.district_id ORDER BY female_account_holders DESC LIMIT 9;
SELECT d.A2 AS district_name, SUM(t.amount) AS total_withdrawals FROM trans t JOIN account a ON t.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE t.type = 'VYDAJ' AND t.date LIKE '1996-01%' GROUP BY d.A2 ORDER BY total_withdrawals DESC LIMIT 10;
SELECT COUNT(*) AS count_without_card FROM account a JOIN district d ON a.district_id = d.district_id WHERE d.A3 = 'South Bohemia' AND NOT EXISTS ( SELECT 1 FROM disp di JOIN card c ON di.disp_id = c.disp_id WHERE di.account_id = a.account_id );
SELECT d.A3 AS district_name, COUNT(*) AS active_loans FROM loan l JOIN account a ON l.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE l.status IN ('C', 'D') GROUP BY d.district_id ORDER BY active_loans DESC LIMIT 1;
SELECT AVG(amount) AS average_loan_amount FROM loan JOIN disp ON loan.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE client.gender = 'M';
SELECT district_id, A2 AS district_name FROM district ORDER BY A13 DESC LIMIT 1;
SELECT COUNT(account_id) AS account_count FROM account WHERE district_id = ( SELECT district_id FROM district WHERE A16 IS NOT NULL ORDER BY A16 DESC LIMIT 1 );
SELECT COUNT(DISTINCT t.account_id) AS count_of_accounts FROM trans AS t JOIN account AS a ON t.account_id = a.account_id WHERE t.operation = 'VYBER KARTOU' AND t.balance < 0 AND a.frequency = 'POPLATEK MESICNE';
SELECT COUNT(*) FROM loan l JOIN account a ON l.account_id = a.account_id WHERE l.date BETWEEN '1900-01-01' AND '2000-12-31' AND l.amount >= 1000 AND a.frequency = 'monthly';
SELECT COUNT(DISTINCT loan.account_id) AS running_contract_count FROM loan JOIN account ON loan.account_id = account.account_id WHERE account.district_id = 1 AND loan.status IN ('C', 'D');
WITH crime_rank AS ( SELECT district_id, A15 AS crimes_1995 FROM district WHERE A15 IS NOT NULL ORDER BY crimes_1995 DESC ) SELECT COUNT(*) as male_clients_count FROM client WHERE gender = 'M' AND district_id = ( SELECT district_id FROM crime_rank WHERE row_number() OVER (ORDER BY crimes_1995 DESC) = 2 );
SELECT COUNT(*) AS high_level_owner_cards FROM card JOIN disp ON card.disp_id = disp.disp_id WHERE card.type = 'gold' AND disp.type = 'OWNER';
SELECT COUNT(*) AS count_pisek FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Pisek';
SELECT DISTINCT d.district_id FROM trans t JOIN account a ON t.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE YEAR(t.date) = 1997 AND t.amount > 10000;
SELECT DISTINCT o.account_id FROM `order` AS o JOIN account AS a ON o.account_id = a.account_id JOIN district AS d ON a.district_id = d.district_id WHERE o.k_symbol = 'SIPO' AND d.A2 = 'Pisek';
SELECT DISTINCT a.account_id FROM account a JOIN disp d ON a.account_id = d.account_id JOIN card c ON d.disp_id = c.disp_id WHERE c.type = 'gold';
SELECT AVG(amount) AS average_amount FROM trans WHERE operation = 'VYBER KARTOU' AND date >= '2021-01-01' AND date <= '2021-01-31';
WITH avg_amounts AS ( SELECT account_id, AVG(amount) as avg_amt FROM trans WHERE operation = 'VYBER KARTOU' AND date >= '1998-01-01' AND date <= '1998-12-31' GROUP BY account_id ) SELECT t.account_id, t.amount FROM trans t JOIN avg_amounts a ON t.account_id = a.account_id WHERE t.operation = 'VYBER KARTOU' AND t.date >= '1998-01-01' AND t.date <= '1998-12-31' AND t.amount < a.avg_amt;
SELECT DISTINCT a.account_id, c.client_id, c.gender FROM client c JOIN account a ON c.district_id = a.district_id JOIN disp d ON a.account_id = d.account_id AND c.client_id = d.client_id WHERE c.gender = 'F' AND EXISTS ( SELECT 1 FROM card cr WHERE cr.disp_id = d.disp_id ) AND EXISTS ( SELECT 1 FROM loan l WHERE l.account_id = a.account_id );
SELECT COUNT(*) FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'F' AND d.A3 = 'south Bohemia';
SELECT a.account_id, d.district_id FROM account AS a JOIN district AS d ON a.district_id = d.district_id JOIN disp AS dp ON a.account_id = dp.account_id WHERE d.A2 = 'Tabor' AND dp.type = 'OWNER';
SELECT DISTINCT a.type AS account_type, d.A11 AS average_income FROM account a INNER JOIN district d ON a.district_id = d.district_id INNER JOIN disp dp ON a.account_id = dp.account_id INNER JOIN client c ON dp.client_id = c.client_id WHERE d.A11 BETWEEN 8000 AND 9000 AND a.type NOT IN ('OWNER');
SELECT COUNT(DISTINCT a.account_id) AS account_count FROM trans t JOIN account a ON t.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE d.A3 = 'North Bohemia' AND t.bank = 'AB';
SELECT DISTINCT d.A2 AS district_name FROM trans t JOIN account a ON t.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE t.type = 'VYDAJ';
SELECT AVG(A15) AS average_crimes_1995 FROM district WHERE A15 > 4000 AND EXISTS ( SELECT 1 FROM account WHERE account.district_id = district.district_id AND date >= '1997-01-01' );
SELECT COUNT(*) AS classic_loan_eligible_cards FROM card LEFT JOIN disp ON card.disp_id = disp.disp_id LEFT JOIN account ON disp.account_id = account.account_id WHERE card.type = 'classic' AND account.type = 'OWNER';
SELECT COUNT(*) FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.gender = 'M' AND d.A2 = 'Hl.m. Praha';
SELECT (SELECT COUNT(*) FROM card WHERE type = 'gold' AND issued < '1998-01-01') / (SELECT COUNT(*) FROM card) * 100 AS gold_card_percentage_prior_1998;
SELECT client.client_id FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE loan.amount = ( SELECT MAX(loan.amount) FROM loan );
SELECT A15 AS crime_count FROM district JOIN account ON district.district_id = account.district_id WHERE account.account_id = 532;
SELECT a.district_id FROM `order` AS o JOIN account AS a ON o.account_id = a.account_id WHERE o.order_id = 33333;
SELECT trans.trans_id, trans.date, trans.amount, trans.balance, trans.type, district.A2 FROM trans LEFT JOIN disp ON trans.account_id = disp.account_id LEFT JOIN client ON disp.client_id = client.client_id LEFT JOIN account ON disp.account_id = account.account_id LEFT JOIN district ON account.district_id = district.district_id WHERE client.client_id = 3356 AND trans.operation = 'VYBER';
SELECT COUNT(DISTINCT a.account_id) AS weekly_issuance_accounts_with_loans_under_200k FROM account a JOIN loan l ON a.account_id = l.account_id WHERE a.frequency = 'POPLATEK TYDNE' AND l.amount < 200000;
SELECT ca.type AS card_type FROM client c INNER JOIN disp d ON d.client_id = c.client_id INNER JOIN card ca ON ca.disp_id = d.disp_id WHERE c.client_id = 13539;
SELECT district.A3 AS region FROM client INNER JOIN district ON client.district_id = district.district_id WHERE client.client_id = 3541 LIMIT 1;
SELECT district_id, COUNT(*) AS account_count FROM account JOIN loan USING (account_id) WHERE status = 'A' GROUP BY district_id ORDER BY account_count DESC;
SELECT o.order_id, c.client_id, c.gender, c.birth_date, c.district_id FROM `order` AS o INNER JOIN account AS a ON o.account_id = a.account_id INNER JOIN disp AS d ON a.account_id = d.account_id INNER JOIN client AS c ON d.client_id = c.client_id WHERE o.order_id = 32423;
SELECT t.trans_id, t.date, t.type, t.operation, t.amount, t.balance FROM trans AS t JOIN account AS a ON t.account_id = a.account_id JOIN district AS d ON a.district_id = d.district_id WHERE d.district_id = 5;
SELECT COUNT(account_id) FROM account WHERE district_id = 8;
SELECT DISTINCT c.client_id FROM card AS ca JOIN disp AS d ON ca.disp_id = d.disp_id WHERE ca.issued >= '1997-01-01' AND d.type = 'junior';
SELECT (COUNT(CASE WHEN gender = 'F' THEN 1 END) / COUNT(*)) * 100 AS female_percentage FROM client WHERE district_id IN ( SELECT DISTINCT district_id FROM district WHERE A11 > 10000 ) AND gender = 'F';
SELECT ((SUM(CASE WHEN YEAR(date) = 1997 THEN amount ELSE 0 END) - SUM(CASE WHEN YEAR(date) = 1996 THEN amount ELSE 0 END)) / SUM(CASE WHEN YEAR(date) = 1996 THEN amount ELSE 0 END)) * 100 AS growth_rate FROM loan JOIN account ON loan.account_id = account.account_id JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE client.gender = 'M' AND status = 'Active' GROUP BY YEAR(date);
SELECT COUNT(*) FROM trans WHERE operation = 'VYBER KARTOU' AND date > '1995-01-01';
SELECT (SUM(CASE WHEN A3 = 'North Bohemia' THEN A16 ELSE 0 END) - SUM(CASE WHEN A3 = 'East Bohemia' THEN A16 ELSE 0 END)) AS Difference FROM district;
SELECT COUNT(*) AS total_dispositions FROM disp INNER JOIN account ON disp.account_id = account.account_id WHERE account.account_id BETWEEN 1 AND 10 AND disp.type IN ('owner', 'disponent');
SELECT frequency FROM account WHERE account_id = 3; SELECT COUNT(*) AS total_debit_3539, k_symbol AS purpose FROM trans WHERE amount = -3539 GROUP BY k_symbol;
SELECT YEAR(birth_date) AS birth_year FROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN account ON disp.account_id = account.account_id WHERE account.account_id = 130;
SELECT COUNT(DISTINCT a.account_id) AS account_count FROM account a JOIN disp d ON a.account_id = d.account_id WHERE a.frequency = 'POPLATEK PO OBRATU';
WITH client_loans AS ( SELECT l.account_id, SUM(l.amount) as total_loan_amount FROM loan l JOIN account a ON l.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE c.client_id = 992 GROUP BY l.account_id ), client_payments AS ( SELECT t.amount as payment_amount, t.operation FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE c.client_id = 992 AND t.type = 'payment' ) SELECT cl.total_loan_amount as total_debt, SUM(cp.payment_amount) as total_payments_made FROM client_loans cl LEFT JOIN client_payments cp ON cl.account_id = cp.account_id;
SELECT c.gender AS client_gender, SUM(t.balance) AS total_balance_after_transaction FROM trans t JOIN account a ON t.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id AND d.client_id = 4 JOIN client c ON d.client_id = c.client_id WHERE t.trans_id >= 851;
SELECT card.type AS credit_card_type FROM client INNER JOIN disp ON client.client_id = disp.client_id INNER JOIN card ON disp.disp_id = card.disp_id WHERE client.client_id = 9;
SELECT SUM(amount) AS total_payment FROM trans WHERE account_id IN ( SELECT account_id FROM disp WHERE client_id = 617 ) AND YEAR(date) = 1998;
SELECT c.client_id, c.birth_date, d.A2 AS branch_name FROM client c JOIN district d ON c.district_id = d.district_id WHERE c.birth_date BETWEEN '1983-01-01' AND '1987-12-31' AND d.A2 = 'East Bohemia';
SELECT DISTINCT c.client_id FROM loan l JOIN account a ON l.account_id = a.account_id JOIN disp d ON a.account_id = d.account_id JOIN client c ON d.client_id = c.client_id WHERE c.gender = 'F' ORDER BY l.amount DESC LIMIT 3;
SELECT COUNT(client_id) AS male_customers_count FROM client JOIN disp ON client.client_id = disp.client_id JOIN account ON disp.account_id = account.account_id JOIN trans ON account.account_id = trans.account_id WHERE client.gender = 'M' AND client.birth_date BETWEEN '1974-01-01' AND '1976-12-31' AND trans.operation = 'SIPO' AND trans.amount > 4000;
SELECT COUNT(*) FROM account WHERE district_id IN ( SELECT district_id FROM district WHERE A2 = 'Beroun' ) AND date > '1996-01-01';
SELECT COUNT(DISTINCT client.client_id) AS female_junior_cardholders FROM client JOIN disp ON disp.client_id = client.client_id JOIN card ON card.disp_id = disp.disp_id WHERE client.gender = 'F' AND card.type = 'junior';
SELECT ROUND((COUNT(CASE WHEN c.gender = 'F' THEN 1 END) / COUNT(DISTINCT c.client_id)) * 100, 2) AS female_percentage FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id JOIN district dis ON a.district_id = dis.district_id WHERE dis.A3 = 'Prague';
SELECT (COUNT(DISTINCT c.client_id) / (SELECT COUNT(DISTINCT client_id) FROM trans WHERE type = 'POPLATEK TYDNE')) * 100 AS percentage FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id LEFT JOIN trans t ON a.account_id = t.account_id WHERE c.gender = 'M' AND t.type = 'POPLATEK TYDNE';
SELECT COUNT(DISTINCT client.client_id) AS number_of_clients FROM account JOIN disp ON account.account_id = disp.account_id JOIN client ON disp.client_id = client.client_id WHERE account.frequency = 'POPLATEK TYDNE';
SELECT a.account_id, MIN(l.amount) AS lowest_approved_amount FROM account a JOIN loan l ON a.account_id = l.account_id WHERE l.status IS NOT NULL AND l.duration > 24 AND a.date < '1997-01-01' GROUP BY a.account_id ORDER BY lowest_approved_amount ASC LIMIT 1;
SELECT c.client_id, a.account_id FROM client c JOIN disp d ON c.client_id = d.client_id JOIN account a ON d.account_id = a.account_id JOIN district dist ON c.district_id = dist.district_id WHERE c.gender = 'F' GROUP BY c.client_id HAVING (DATEDIFF(CURDATE(), c.birth_date) / 365.25) = ( SELECT MAX(DATEDIFF(CURDATE(), birth_date) / 365.25) FROM client WHERE gender = 'F' ) AND dist.A11 = ( SELECT MIN(A11) FROM district WHERE district_id IN ( SELECT c.district_id FROM client c WHERE gender = 'F' ) );
SELECT COUNT(DISTINCT client.client_id) AS count_1920_east_bohemia FROM client INNER JOIN district ON client.district_id = district.district_id WHERE client.birth_date = '1920-01-01' AND district.A3 = 'East Bohemia';
SELECT COUNT(*) FROM loan JOIN account USING (account_id) WHERE loan.duration = 24 AND account.frequency = 'POPLATEK TYDNE';
SELECT AVG(l.amount) AS average_loan_amount FROM loan l INNER JOIN trans t ON l.account_id = t.account_id WHERE l.status IN ('C', 'D') AND t.operation = 'POPLATEK PO OBRATU';
SELECT c.client_id, c.district_id FROM client c JOIN disp d ON c.client_id = d.client_id LEFT JOIN loan l ON d.account_id = l.account_id LEFT JOIN `order` o ON d.account_id = o.account_id WHERE (l.loan_id IS NOT NULL OR o.k_symbol = 'permanent' AND o.order_id IS NOT NULL) GROUP BY c.client_id, c.district_id HAVING COUNT(*) >= 1;
SELECT client.client_id, FLOOR((date('now') - client.birth_date)/365.25) AS age FROM client JOIN disp ON client.client_id = disp.client_id JOIN card ON disp.disp_id = card.disp_id WHERE card.type = 'gold' AND disp.type = 'OWNER';
SELECT bond_type FROM ( SELECT bond_type, COUNT(*) AS count FROM bond GROUP BY bond_type ) AS subquery WHERE count = (SELECT MAX(count) FROM ( SELECT COUNT(*) AS count FROM bond GROUP BY bond_type ) AS max_subquery)
SELECT COUNT(DISTINCT m.molecule_id) AS chlorinated_non_carcinogenic_molecules FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'cl' AND m.label = '-';
SELECT AVG(COUNT(a.element = 'O')) AS average_oxygen FROM atom a WHERE a.molecule_id IN ( SELECT b.molecule_id FROM bond b WHERE b.bond_type = '-' ) GROUP BY a.molecule_id;
SELECT (COUNT(*) FILTER (WHERE bond_type = '-')) / (COUNT(DISTINCT a.atom_id) FILTER (WHERE m.label = '+')) FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id JOIN molecule m ON a1.molecule_id = m.molecule_id WHERE m.label = '+';
SELECT COUNT(DISTINCT a.atom_id) AS non_carcinogenic_sodium_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'na' AND m.label = '-';
SELECT DISTINCT m.molecule_id FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '#' HAVING m.label = '+'
SELECT (COUNT(DISTINCT CASE WHEN a.element = 'c' THEN c.atom_id END) / COUNT(DISTINCT c.atom_id)) * 100 AS percentage_of_carbon_in_double_bonds FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a ON c.atom_id = a.atom_id WHERE b.bond_type = '=';
SELECT COUNT(*) FROM bond WHERE bond_type = '#';
SELECT COUNT(*) FROM atom WHERE element != 'Br';
SELECT COUNT(molecule_id) AS carcinogenic_count FROM molecule WHERE label = '+' AND molecule_id >= 'TR000' AND molecule_id <= 'TR099';
SELECT DISTINCT a.molecule_id FROM atom a WHERE a.element = 'c';
SELECT a.element AS element1, a2.element AS element2 FROM connected c JOIN atom a ON c.atom_id = a.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE c.bond_id = 'TR004_8_9';
SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '=';
SELECT label AS most NumerousLabel FROM ( SELECT m.label, COUNT(*) AS label_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'h' GROUP BY m.label ) AS subquery WHERE label_count = ( SELECT MAX(label_count) FROM ( SELECT COUNT(*) AS label_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'h' GROUP BY m.label ) AS count_subquery );
SELECT b.bond_type, c.molecule_id FROM bond AS b JOIN connected AS c ON b.bond_id = c.bond_id WHERE (c.atom_id IN ( SELECT a.atom_id FROM atom AS a WHERE a.element = 'cl' )) OR (c.atom_id2 IN ( SELECT a.atom_id FROM atom AS a WHERE a.element = 'cl' )) GROUP BY b.bond_id, c.molecule_id;
SELECT c.atom_id, c.atom_id2 FROM connected AS c INNER JOIN bond AS b ON c.bond_id = b.bond_id WHERE b.bond_type = '-';
SELECT c.atom_id AS atom1, c.atom_id2 AS atom2 FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id JOIN connected c ON b.bond_id = c.bond_id WHERE m.label = '-';
SELECT a.element AS least_element, COUNT(a.element) AS least_count FROM atom a JOIN ( SELECT molecule_id FROM molecule WHERE label = '-' ) m ON a.molecule_id = m.molecule_id GROUP BY a.element ORDER BY least_count ASC LIMIT 1;
SELECT b.bond_type FROM bond AS b JOIN connected AS c ON c.bond_id = b.bond_id WHERE (c.atom_id = 'TR004_8' AND c.atom_id2 = 'TR004_20') OR (c.atom_id = 'TR004_20' AND c.atom_id2 = 'TR004_8') LIMIT 1;
SELECT label AS missing_label FROM ( SELECT '+' UNION SELECT '-' ) AS all_labels WHERE all_labels.label NOT IN ( SELECT m.label FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE a.element = 'sn' );
SELECT COUNT(DISTINCT a.atom_id) FROM atom a JOIN connected c ON a.atom_id = c.atom_id WHERE NOT EXISTS ( SELECT 1 FROM bond b WHERE b.molecule_id = c.molecule_id AND b.bond_type != '-' ) AND (a.element = 'i' OR a.element = 's');
SELECT c.atom_id, c.atom_id2, a.molecule_id AS molecule_id FROM connected AS c JOIN bond AS b ON c.bond_id = b.bond_id AND b.bond_type = '#' JOIN atom AS a ON c.atom_id = a.atom_id;
SELECT DISTINCT a.atom_id FROM atom a JOIN connected c ON a.atom_id = c.atom_id WHERE EXISTS ( SELECT 1 FROM bond b WHERE b.bond_id = c.bond_id AND b.molecule_id = 'TR181' ) AND a.molecule_id != 'TR181';
WITH atom_count AS ( SELECT m.molecule_id, COUNT(*) as total_atoms, COUNT(CASE WHEN a.element = 'f' THEN 1 END) as fluorine_atoms FROM molecule m LEFT JOIN atom a ON m.molecule_id = a.molecule_id GROUP BY m.molecule_id ) SELECT (COUNT(DISTINCT CASE WHEN fluorine_atoms = 0 THEN m.molecule_id ELSE NULL END) * 100.0 / COUNT(DISTINCT m.molecule_id)) AS percentage_without_fluorine FROM molecule m JOIN atom_count ac ON m.molecule_id = ac.molecule_id WHERE m.label = '+';
SELECT (COUNT(*) * 100 / (SELECT COUNT(molecule_id) FROM molecule WHERE label = '+')) AS percent FROM molecule m WHERE label = '+' AND EXISTS ( SELECT 1 FROM connected c JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '#' AND c.molecule_id = m.molecule_id );
SELECT DISTINCT a.element AS element FROM molecule m JOIN connected c ON m.molecule_id = c.molecule_id JOIN atom a ON c.atom_id = a.atom_id WHERE m.molecule_id = 'TR000' ORDER BY element ASC LIMIT 3;
SELECT c.atom_id, c.atom_id2 FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE b.molecule_id = 'TR001' AND b.bond_id = 'TR001_2_6';
SELECT (SELECT COUNT(*) FROM molecule WHERE label = '+' AND molecule_id IS NOT NULL) - (SELECT COUNT(*) FROM molecule WHERE label = '-' AND molecule_id IS NOT NULL) AS difference;
SELECT atom_id AS atom1, atom_id2 AS atom2 FROM connected WHERE bond_id = 'TR000_2_5'
SELECT bond_id FROM connected WHERE atom_id2 = 'TR000_2';
SELECT m.label AS molecule_label, COUNT(*) AS bond_count FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = ' = ' GROUP BY b.molecule_id ORDER BY bond_count DESC, molecule_label ASC LIMIT 5;
SELECT (ROUND((double_bond_count / total_bond_count) * 100, 5)) AS percentage_of_double_bonds FROM ( SELECT COUNT(CASE WHEN bond_type = '=' THEN bond_id END) AS double_bond_count, COUNT(bond_id) AS total_bond_count FROM bond WHERE molecule_id = 'TR008' ) AS subquery;
SELECT ROUND((COUNT(molecule_id) FILTER (WHERE label = '+') / COUNT(molecule_id)) * 100, 3) AS percent_carcinogenic FROM molecule;
SELECT (SUM(CASE WHEN element = 'h' THEN 1 ELSE 0 END) / COUNT(atom_id)) * 100 AS percentage FROM atom WHERE molecule_id = 'TR206';
SELECT bond_type FROM bond WHERE molecule_id = 'TR000';
SELECT label FROM molecule WHERE molecule_id = 'TR060';
SELECT bond_type AS majority_bond_type, (SELECT label FROM molecule WHERE molecule_id = 'TR010') AS is_carcinogenic FROM bond INNER JOIN connected ON bond.bond_id = connected.bond_id WHERE connected.molecule_id = 'TR010' GROUP BY bond_type HAVING COUNT(*) = MAX(COUNT(*)) OVER (PARTITION BY molecule_id);
SELECT m.molecule_id FROM connected c1 JOIN bond b ON c1.bond_id = b.bond_id JOIN atom a1 ON c1.atom_id = a1.atom_id JOIN atom a2 ON c1.atom_id2 = a2.atom_id JOIN molecule m ON a1.molecule_id = m.molecule_id WHERE b.bond_type = 'single' AND m.label = '-' GROUP BY m.molecule_id ORDER BY m.molecule_id ASC LIMIT 3;
SELECT `bond_id`, `bond_type` FROM `bond` WHERE `molecule_id` = 'TR006' ORDER BY `bond_type` LIMIT 2;
SELECT COUNT(DISTINCT bond.bond_id) AS bond_count FROM bond JOIN molecule ON bond.molecule_id = molecule.molecule_id JOIN connected ON bond.bond_id = connected.bond_id WHERE molecule.molecule_id = 'TR009' AND (connected.atom_id = 'TR009_12' OR connected.atom_id2 = 'TR009_12');
SELECT COUNT(DISTINCT m.molecule_id) AS carcinogenic_molecules_with_bromine FROM molecule m INNER JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND a.element = 'br';
SELECT `bond_type` AS BondType FROM `bond` WHERE `bond_id` = 'TR001_6_9' UNION SELECT `atom_id` AS Atom1, `atom_id2` AS Atom2 FROM `connected` WHERE `bond_id` = 'TR001_6_9';
SELECT m.label AS carcinogenic FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.atom_id = 'TR001_10';
SELECT COUNT(DISTINCT molecule_id) FROM bond WHERE bond_type = '#';
SELECT COUNT(DISTINCT bond_id) AS connection_count FROM connected WHERE atom_id LIKE 'TR%_19' OR atom_id2 LIKE 'TR%_19';
SELECT a.atom_id, a.element FROM atom AS a JOIN molecule AS m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR004';
SELECT COUNT(*) FROM molecule WHERE label = '-';
SELECT m.molecule_id, m.label FROM molecule m WHERE m.molecule_id IN ( SELECT DISTINCT a.molecule_id FROM atom a WHERE SUBSTR(a.atom_id, 7, 2) BETWEEN '21' AND '25' ) AND m.label = '+';
SELECT b.bond_id, b.bond_type FROM bond AS b JOIN connected AS c ON c.bond_id = b.bond_id JOIN atom AS a1 ON c.atom_id = a1.atom_id JOIN atom AS a2 ON c.atom_id2 = a2.atom_id WHERE (a1.element = 'p' AND a2.element = 'n') OR (a1.element = 'n' AND a2.element = 'p');
SELECT CASE WHEN m.label = '+' THEN 'Yes' ELSE 'No' END AS carcinogenic FROM ( SELECT c.molecule_id, COUNT(DISTINCT c.bond_id) AS double_bond_count FROM connected c WHERE c.bond_type = ' = ' GROUP BY c.molecule_id ) max_doubles JOIN molecule m ON max_doubles.molecule_id = m.molecule_id WHERE max_doubles.double_bond_count = ( SELECT MAX(double_bond_count) FROM ( SELECT COUNT(DISTINCT bond_id) AS double_bond_count FROM connected WHERE bond_type = ' = ' GROUP BY molecule_id ) AS counts );
SELECT
SELECT b.bond_type, c.bond_id FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE (SUBSTR(a.atom_id, 7, 2) + 0) = 45;
SELECT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected);
SELECT DISTINCT atom_id AS atom FROM bond JOIN connected USING (bond_id) JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR041' AND bond_type = '#' UNION SELECT DISTINCT atom_id2 AS atom FROM bond JOIN connected USING (bond_id) JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR041' AND bond_type = '#';
SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 WHERE c.bond_id = 'TR144_8_19' AND c.molecule_id IS NOT NULL;
SELECT m.molecule_id, COUNT(b.bond_id) AS double_bond_count FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_type = ' = ' AND m.label = '+' GROUP BY m.molecule_id ORDER BY double_bond_count DESC LIMIT 1;
WITH element_counts AS ( SELECT a.element, COUNT(DISTINCT a.atom_id) AS count FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' GROUP BY a.element ) SELECT e.element, e.count, RANK() OVER (ORDER BY e.count ASC) AS rank FROM element_counts e WHERE e.rank = 1;
SELECT DISTINCT atom_id FROM ( SELECT atom_id FROM atom WHERE element = 'pb' UNION SELECT c2.atom_id FROM connected c1 JOIN bond b ON c1.bond_id = b.bond_id JOIN connected c2 ON c2.bond_id = b.bond_id AND c2.atom_id != c1.atom_id WHERE c1.atom_id IN (SELECT atom_id FROM atom WHERE element = 'pb') ) AS combined;
SELECT atom.element AS element1, atom2.element AS element2 FROM bond JOIN connected ON bond.bond_id = connected.bond_id JOIN atom ON connected.atom_id = atom.atom_id JOIN atom AS atom2 ON connected.atom_id2 = atom2.atom_id WHERE bond.bond_type = '#';
WITH bond_elements AS ( SELECT c.bond_id, a1.element as element1, a2.element as element2 FROM connected c JOIN atom a1 ON c.atom1 = a1.atom_id JOIN atom a2 ON c.atom2 = a2.atom_id ), element_counts AS ( SELECT element1, element2, COUNT(*) as count FROM bond_elements GROUP BY element1, element2 ) SELECT (count / total_bonds * 100) AS percentage, element1, element2 FROM element_counts WHERE count = ( SELECT MAX(count) FROM element_counts );
SELECT ROUND((SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END) * 100) / COUNT(b.bond_id), 5) AS proportion_carcinogenic_single_bonds FROM bond b INNER JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '-';
SELECT COUNT(*) FROM atom WHERE element IN ('C', 'H');
SELECT c.atom_id2 AS connected_atom FROM connected c JOIN atom a ON c.atom_id = a.atom_id WHERE a.element = 's'; UNION SELECT c.atom_id AS connected_atom FROM connected c JOIN atom a ON c.atom_id2 = a.atom_id WHERE a.element = 's';
SELECT b.bond_type FROM bond AS b JOIN molecule AS m ON b.molecule_id = m.molecule_id JOIN connected AS c1 ON b.bond_id = c1.bond_id JOIN atom AS a1 ON c1.atom_id = a1.atom_id JOIN connected AS c2 ON b.bond_id = c2.bond_id JOIN atom AS a2 ON c2.atom_id2 = a2.atom_id WHERE a1.element = 'sn' OR a2.element = 'sn';
SELECT COUNT(DISTINCT element) AS single_bond_elements_count FROM atom WHERE molecule_id IN ( SELECT molecule_id FROM bond WHERE bond_type = '-' );
SELECT COUNT(a.atom_id) FROM atom a WHERE a.molecule_id IN ( SELECT m.molecule_id FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '#' AND EXISTS ( SELECT 1 FROM atom a2 WHERE a2.molecule_id = m.molecule_id AND a2.element IN ('p', 'br') ) );
SELECT bond.bond_id FROM bond INNER JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE molecule.label = '+';
SELECT DISTINCT m.molecule_id FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '-' AND m.label = '-' ORDER BY m.molecule_id;
SELECT (CASE WHEN total_atoms = 0 THEN 0 ELSE (chlorine_count / total_atoms * 100) END) AS chlorine_percentage FROM ( SELECT COUNT(DISTINCT atom_id) AS total_atoms, SUM(CASE WHEN element = 'cl' THEN 1 ELSE 0 END) AS chlorine_count FROM connected c JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '-' ) subquery;
SELECT label FROM molecule WHERE molecule_id = 'TR000' OR molecule_id = 'TR001' OR molecule_id = 'TR002';
SELECT molecule_id FROM molecule WHERE label = '-';
SELECT COUNT(DISTINCT m.molecule_id) AS total_carcinogenic_molecules FROM molecule m WHERE m.molecule_id BETWEEN 'TR000' AND 'TR030' AND m.label = '+';
SELECT bond_type FROM bond WHERE molecule_id >= 'TR000' AND molecule_id <= 'TR050';
SELECT a.element AS atom1_element, b.element AS atom2_element FROM connected c LEFT JOIN atom a ON c.atom_id = a.atom_id LEFT JOIN atom b ON c.atom_id2 = b.atom_id WHERE c.bond_id = 'TR001_10_11';
WITH IodineAtoms AS ( SELECT atom_id FROM atom WHERE element = 'I' ) SELECT COUNT(DISTINCT c.bond_id) FROM connected c WHERE c.atom_id IN (SELECT atom_id FROM IodineAtoms) OR c.atom_id2 IN (SELECT atom_id FROM IodineAtoms);
SELECT m.molecule_id, MAX(m.label) AS carcinogenicity FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE a.element = 'ca' GROUP BY m.molecule_id ORDER BY carcinogenicity;
SELECT DISTINCT a.element FROM connected c1 JOIN connected c2 ON c1.bond_id = c2.bond_id WHERE c1.bond_id = 'TR001_1_8' AND ( EXISTS ( SELECT 1 FROM atom WHERE atom_id = c1.atom_id AND element = 'cl' ) OR EXISTS ( SELECT 1 FROM atom WHERE atom_id = c1.atom_id2 AND element = 'cl' ) ) AND ( EXISTS ( SELECT 1 FROM atom WHERE atom_id = c1.atom_id AND element = 'c' ) OR EXISTS ( SELECT 1 FROM atom WHERE atom_id = c1.atom_id2 AND element = 'c' ) );
SELECT m.molecule_id FROM molecule m WHERE m.label = '-' AND EXISTS ( SELECT 1 FROM bond b WHERE b.molecule_id = m.molecule_id AND b.bond_type = '#' ) AND NOT EXISTS ( SELECT 1 FROM connected c JOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id WHERE c.molecule_id = m.molecule_id AND a.element != 'c' );
WITH carcinogenic_molecules AS ( SELECT m.*, a.* FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' ) SELECT (COUNT(CASE WHEN element = 'cl' THEN 1 END) * 100.0 / COUNT(a.atom_id)) AS chlorine_percentage FROM carcinogenic_molecules;
SELECT DISTINCT a.element AS toxicology_element FROM molecule m LEFT JOIN connected c ON m.molecule_id = c.molecule_id LEFT JOIN bond b ON c.bond_id = b.bond_id LEFT JOIN atom a ON c.atom_id = a.atom_id WHERE m.molecule_id = 'TR001';
SELECT DISTINCT molecule_id FROM bond WHERE bond_type = ' = ';
SELECT c.atom_id AS first_atom, c.atom_id2 AS second_atom FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE b.bond_type = '#';
SELECT element FROM atom WHERE molecule_id = (SELECT molecule_id FROM bond WHERE bond_id = 'TR000_1_2');
SELECT COUNT(DISTINCT m.molecule_id) AS non_carcinogenic_single_bond_molecules FROM molecule m JOIN connected c ON m.molecule_id = c.molecule_id -- 连接connected表获取分子ID JOIN bond b ON c.bond_id = b.bond_id -- 连接bond表筛选单键类型 WHERE b.bond_type = '-' -- 单键类型筛选 AND m.label = '-'; -- 非致癌分子筛选
SELECT label FROM molecule WHERE molecule_id = ( SELECT molecule_id FROM bond WHERE bond_id = 'TR001_10_11' );
SELECT bond.bond_id, molecule.label FROM bond JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE bond.bond_type = '#';
WITH toxicology_tally AS ( SELECT a.element, COUNT(DISTINCT a.element) OVER () AS total_toxicology_elements FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.label = '+' AND (SELECT ROW_NUMBER() OVER (PARTITION BY a.molecule_id ORDER BY a.atom_id)) = 4 ) SELECT element, total_toxicology_elements FROM toxicology_tally;
SELECT (SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR006' AND element = 'h') / (SELECT COUNT(*) FROM atom WHERE molecule_id = 'TR006') AS hydrogen_ratio, m.label AS label FROM molecule m WHERE m.molecule_id = 'TR006';
SELECT DISTINCT m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'ca';
SELECT b.bond_type FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE a.element = 'c';
SELECT element FROM atom WHERE atom_id IN ( SUBSTR('TR001_10_11', 7, 2), SUBSTR('TR001_10_11', 10, 2) );
SELECT ROUND((COUNT(*) / (SELECT COUNT(*) FROM molecule)) * 100, 2) AS percent_triple_bond FROM ( SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '#' ) AS triple_bonds;
SELECT (COUNT(CASE WHEN bond_type = ' =' THEN 1 END) / COUNT(DISTINCT bond_id)) * 100 AS percent FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id WHERE m.molecule_id = 'TR047';
SELECT m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.atom_id = 'TR001_1';
SELECT label FROM molecule WHERE molecule_id = 'TR151';
SELECT DISTINCT `element` FROM `atom` AS a WHERE `molecule_id` = 'TR151';
SELECT COUNT(*) FROM molecule WHERE label = '+';
SELECT atom.atom_id FROM atom INNER JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.element = 'c' AND molecule.molecule_id LIKE 'TR%' AND substr(molecule.molecule_id,3,3) >= '010' AND substr(molecule.molecule_id,3,3) <= '050';
SELECT m.molecule_id, COUNT(DISTINCT a.atom_id) AS atom_count FROM molecule m LEFT JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' GROUP BY m.molecule_id;
SELECT DISTINCT c.bond_id FROM connected c JOIN bond b ON c.bond_id = b.bond_id JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = ' = ' AND m.label = '+';
SELECT COUNT(DISTINCT a.atom_id) AS hydrogen_atom_count FROM atom a LEFT JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'H' AND m.label = '+';
SELECT b.molecule_id FROM bond AS b JOIN connected AS c ON b.bond_id = c.bond_id WHERE c.atom_id = 'TR000_1' AND b.bond_id = 'TR000_1_2';
SELECT DISTINCT a.atom_id, m.molecule_id FROM atom a JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id JOIN molecule m ON b.molecule_id = m.molecule_id WHERE a.element = 'c' AND m.label = '-';
SELECT (COUNT(*) FILTER (WHERE element = 'h') / COUNT(*)) * 100 AS percentage FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '+');
SELECT label FROM molecule WHERE molecule_id = 'TR124';
SELECT a.atom_id AS atomic_number, a.element AS element_name FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE m.molecule_id = 'TR186';
SELECT DISTINCT b.bond_type FROM bond b WHERE b.molecule_id = ( SELECT m.molecule_id FROM molecule m WHERE m.label = 'TR007_4_19' ) AND EXISTS ( SELECT 1 FROM connected c WHERE c.bond_id = b.bond_id LIMIT 1 );
SELECT a.element AS element1, a2.element AS element2 FROM connected c JOIN atom a ON c.atom_id = a.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE c.bond_id = 'TR001_2_4';
SELECT COUNT(DISTINCT c.bond_id) AS double_bond_count, m.label AS is_carcinogenic FROM bond b LEFT JOIN connected c ON b.bond_id = c.bond_id LEFT JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = ' = ' AND m.molecule_id = 'TR006';
SELECT m.molecule_id AS Molecule_ID, a.element AS Element FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' GROUP BY m.molecule_id, a.element;
SELECT bond.bond_id AS bond_id, mol.label AS molecule_label, c.atom_id AS atom1, c.atom_id2 AS atom2 FROM bond JOIN connected c ON bond.bond_id = c.bond_id JOIN molecule mol ON bond.molecule_id = mol.molecule_id WHERE bond.bond_type = '-';
SELECT DISTINCT m.molecule_id, GROUP_CONCAT(DISTINCT a.element) AS elements FROM molecule m LEFT JOIN bond b ON m.molecule_id = b.molecule_id LEFT JOIN connected c1 ON b.bond_id = c1.bond_id LEFT JOIN atom a1 ON c1.atom_id = a1.atom_id LEFT JOIN connected c2 ON b.bond_id = c2.bond_id LEFT JOIN atom a2 ON c2.atom_id2 = a2.atom_id WHERE b.bond_type = '#' GROUP BY m.molecule_id, b.bond_id;
SELECT atom.element AS element1, atom2.element AS element2 FROM atom JOIN connected ON atom.atom_id = connected.atom_id JOIN bond ON connected.bond_id = bond.bond_id JOIN molecule ON bond.molecule_id = molecule.molecule_id WHERE bond.bond_id = 'TR000_2_3';
SELECT COUNT(DISTINCT c.bond_id) AS TotalChlorineBonds FROM connected c JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id WHERE a1.element = 'cl' OR a2.element = 'cl';
SELECT a.atom_id AS atom_id, COUNT(DISTINCT b.bond_type) AS bond_types_count FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id LEFT JOIN connected c ON a.atom_id = c.atom_id LEFT JOIN bond b ON c.bond_id = b.bond_id WHERE m.molecule_id = 'TR346' GROUP BY a.atom_id;
SELECT COUNT(*) AS total_molecules_with_double_bond, SUM(CASE WHEN label = '+' THEN 1 ELSE 0 END) AS carcinogenic_count FROM molecule m WHERE EXISTS ( SELECT 1 FROM bond b WHERE b.molecule_id = m.molecule_id AND b.bond_type = ' = ' );
SELECT COUNT(*) AS total_molecules_without_sulphur_and_double_bond FROM molecule m LEFT JOIN ( SELECT atom_id, molecule_id FROM atom a WHERE element = 's' ) s ON m.molecule_id = s.molecule_id LEFT JOIN ( SELECT bond_id, molecule_id FROM bond b WHERE bond_type = ' = ' ) db ON m.molecule_id = db.molecule_id WHERE s.atom_id IS NULL AND db.bond_id IS NULL;
SELECT m.label FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_id = 'TR001_2_4';
SELECT COUNT(atom_id) FROM atom WHERE molecule_id = 'TR001';
SELECT COUNT(*) FROM bond WHERE bond_type = '-';
SELECT DISTINCT m.molecule_id FROM molecule m WHERE EXISTS ( SELECT 1 FROM atom a WHERE a.element = 'Cl' AND a.molecule_id = m.molecule_id ) AND m.label = '+' ORDER BY m.molecule_id;
SELECT DISTINCT m.molecule_id, m.label FROM atom a JOIN molecule m ON a.molecule_id = m.molecule_id WHERE a.element = 'c' AND m.label != '';
SELECT (ROUND((COUNT(DISTINCT m.molecule_id) / SUM(CASE WHEN m.label = '+' THEN 1 ELSE 0 END)) * 100, 2)) AS percentage FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND a.element = 'cl';
SELECT molecule_id FROM bond WHERE bond_id = 'TR001_1_7';
SELECT COUNT(DISTINCT a.element) AS element_count FROM connected c LEFT JOIN atom a ON c.atom_id = a.atom_id WHERE c.bond_id = 'TR001_3_4';
SELECT bond_type FROM connected INNER JOIN bond ON connected.bond_id = bond.bond_id WHERE (atom_id = 'TR000_1' AND atom_id2 = 'TR000_2') OR (atom_id = 'TR000_2' AND atom_id2 = 'TR000_1');
SELECT a.molecule_id AS molecule_id FROM atom a WHERE a.atom_id = 'TR000_2' AND EXISTS ( SELECT 1 FROM atom a2 WHERE a2.atom_id = 'TR000_4' AND a2.molecule_id = a.molecule_id );
SELECT element FROM atom WHERE atom_id = 'TR000_1';
SELECT label FROM molecule WHERE molecule_id = 'TR000';
SELECT (COUNT(*) / (SELECT COUNT(bond_id) FROM bond)) * 100 AS percentage_single_bond FROM bond WHERE bond_type = '-';
SELECT COUNT(DISTINCT m.molecule_id) FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND a.element = 'n';
SELECT m.molecule_id FROM molecule m WHERE EXISTS ( SELECT 1 FROM bond b JOIN connected c ON b.bond_id = c.bond_id WHERE b.bond_type = ' = ' AND (EXISTS ( SELECT 1 FROM atom a WHERE a.atom_id = c.atom_id AND a.element = 's' ) OR EXISTS ( SELECT 1 FROM atom a WHERE a.atom_id = c.atom_id2 AND a.element = 's' )) );
WITH atom_count AS ( SELECT molecule_id, COUNT(atom_id) as atom_count FROM atom WHERE molecule_id IS NOT NULL GROUP BY molecule_id ) SELECT m.molecule_id, m.label FROM molecule m JOIN atom_count ac ON m.molecule_id = ac.molecule_id WHERE m.label = '-' AND ac.atom_count > 5;
SELECT DISTINCT a.element FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id AND b.bond_type = '=' JOIN connected c ON b.bond_id = c.bond_id JOIN atom a ON c.atom_id = a.atom_id WHERE m.molecule_id = 'TR024' UNION SELECT DISTINCT a.element FROM molecule m JOIN bond b ON m.molecule_id = b.molecule_id AND b.bond_type = '=' JOIN connected c ON b.bond_id = c.bond_id JOIN atom a ON c.atom_id2 = a.atom_id WHERE m.molecule_id = 'TR024';
SELECT m.molecule_id, COUNT(a.atom_id) AS atom_count FROM molecule m LEFT JOIN atom a ON m.molecule_id = a.molecule_id AND a.element IS NOT NULL WHERE m.label = '+' GROUP BY m.molecule_id ORDER BY atom_count DESC;
SELECT ROUND((COUNT(c.atom_id) * 100.0 / COUNT(a.atom_id)), 2) AS percentage FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id LEFT JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE m.label = '+' AND a.element = 'h' AND b.bond_type = '#';
SELECT COUNT(*) AS carcinogenic_molecules_count FROM molecule WHERE label = '+';
SELECT COUNT(*) AS count_single_bonds FROM bond WHERE molecule_id BETWEEN 'TR004' AND 'TR010' AND bond_type = '-';
SELECT COUNT(atom.atom_id) AS carbon_count FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE molecule.molecule_id = 'TR008' AND atom.element = 'c';
SELECT element FROM atom JOIN molecule ON atom.molecule_id = molecule.molecule_id WHERE atom.atom_id = 'TR004_7' AND molecule.label = '-';
SELECT COUNT(DISTINCT c.molecule_id) AS total_molecules FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a1 ON c.atom_id = a1.atom_id WHERE b.bond_type = ' = ' AND a1.element = 'O';
SELECT COUNT(DISTINCT m.molecule_id) AS non_carcinogenic_molecules_with_triple_bonds FROM molecule m INNER JOIN bond b ON m.molecule_id = b.molecule_id WHERE b.bond_type = '#' AND m.label = '-';
SELECT DISTINCT a.element, b.bond_type FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id JOIN connected c ON a.atom_id = c.atom_id JOIN bond b ON c.bond_id = b.bond_id WHERE m.molecule_id = 'TR002';
SELECT a.atom_id FROM atom AS a JOIN connected AS c ON a.atom_id = c.atom_id JOIN bond AS b ON c.bond_id = b.bond_id WHERE a.element = 'c' AND b.bond_type = ' = ' AND a.molecule_id = 'TR012';
SELECT a.atom_id FROM molecule m JOIN atom a ON m.molecule_id = a.molecule_id WHERE m.label = '+' AND a.element = 'o';
代码块包裹生成的语句，这样用户可以直接复制使用。整个过程要确保逻辑清晰，步骤明确，避免遗漏任何关键点。 </think> 根据你的要求，以下是生成的SQL语句：
SELECT c.uuid, c.name, c.borderColor FROM cards c WHERE c.borderColor = 'Borderless' AND (c.cardKingdomFoilId IS NULL OR c.cardKingdomId IS NULL) ORDER BY c.name;
SELECT name, MAX(faceConvertedManaCost) AS max_face_converted_mana_cost FROM cards GROUP BY uuid ORDER BY max_face_converted_mana_cost DESC;
SELECT name AS CardName, edhrecRank AS EDHRec_Ranking FROM cards WHERE frameVersion = '2015' AND edhrecRank < 100 ORDER BY EDHRec_Ranking ASC;
SELECT DISTINCT c.name, c.rarity FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE l.status = 'Banned' AND l.format = 'gladiator' AND c.rarity = 'mythic';
SELECT c.name AS card_name, l.status AS legality_status FROM cards c LEFT JOIN legalities l ON c.uuid = l.uuid WHERE c.type = 'Artifact' AND c.side IS NULL AND l.format = 'vintage';
SELECT DISTINCT c.id, c.artist FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.format = 'commander' AND l.status = 'Legal' AND (c.power = '*' OR c.power IS NULL);
SELECT c.id, r.text AS ruling_text, c.hasContentWarning FROM cards AS c LEFT JOIN rulings AS r ON c.uuid = r.uuid WHERE c.artist = 'Stephen Daniele';
SELECT r.* FROM cards c INNER JOIN rulings r ON c.uuid = r.uuid WHERE c.name = 'Sublime Epiphany' AND c.number = '74s';
SELECT c.name AS CardName, c.artist AS Artist, c.isPromo FROM cards c JOIN rulings r ON c.uuid = r.uuid GROUP BY c.uuid HAVING COUNT(*) = ( SELECT MAX(sub.count) FROM ( SELECT COUNT(*) as count FROM rulings GROUP BY uuid ) sub ) ORDER BY CardName;
SELECT foreign_data.language FROM foreign_data JOIN cards ON foreign_data.uuid = cards.uuid WHERE cards.name = 'Annul' AND cards.number = '29';
SELECT DISTINCT f.name AS card_name FROM foreign_data f JOIN cards c ON f.uuid = c.uuid WHERE f.language = 'Japanese';
SELECT (COUNT(*) FILTER (WHERE language = 'Chinese Simplified') / COUNT(*)) * 100 AS chinese_simplified_percentage FROM foreign_data;
SELECT s.code AS.setCode, s.name AS.setName, s.releaseDate AS.setReleaseDate, s.totalSetSize AS.setTotalCards FROM sets s WHERE s.code IN ( SELECT DISTINCT st.setCode FROM set_translations st WHERE st.language = 'Italian' );
SELECT COUNT(DISTINCT type) AS types_count FROM cards WHERE artist = 'Aaron Boyd';
code blocks as instructed. </think> To retrieve the keywords for the card named "Angel of Mercy", we need to query the `cards` table and filter the row where the `name` column matches 'Angel of Mercy'. The keyword information is stored in the `keywords` column.
SELECT COUNT(*) FROM cards WHERE power = '*';
SELECT promoTypes FROM cards WHERE name = 'Duress';
SELECT borderColor FROM cards WHERE name = 'Ancestor''s Chosen';
SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen';
SELECT DISTINCT language FROM set_translations WHERE setCode = ( SELECT l.set_code FROM legalities l WHERE l.uuid = ( SELECT uuid FROM cards WHERE name = 'Angel of Mercy' ) ) ORDER BY language;
SELECT COUNT(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.status = 'restricted' AND cards.isTextless = 0;
SELECT r.text AS ruling_description FROM rulings r JOIN cards c ON r.uuid = c.uuid WHERE c.name = 'Ancestor''s Chosen';
SELECT COUNT(*) FROM cards INNER JOIN legalities ON cards.uuid = legalities.uuid WHERE status = 'restricted' AND isStarter = 1;
SELECT legalities.status FROM legalities JOIN cards ON legalities.uuid = cards.uuid WHERE cards.name = 'Cloudchaser Eagle';
SELECT type FROM cards WHERE name = 'Benalish Knight';
SELECT legalities.format, legalities.status FROM legalities INNER JOIN cards ON legalities.uuid = cards.uuid WHERE cards.name = 'Benalish Knight';
SELECT DISTINCT c.artist AS ArtistName FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Phyrexian';
SELECT (COUNT(CASE WHEN borderColor = 'borderless' THEN id END) * 100.0 / COUNT(id)) AS "Borderless Percentage" FROM cards;
SELECT COUNT(*) FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'German' AND cards.isReprint = 1;
SELECT COUNT(DISTINCT c.id) AS russian_borderless_count FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.borderColor = 'borderless' AND fd.language = 'Russian';
SELECT (COUNT(foreign_data.id) / COUNT(cards.id)) * 100 AS french_story_spotlight_percentage FROM cards LEFT JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.isStorySpotlight = 1 AND foreign_data.language = 'French';
SELECT COUNT(*) FROM cards WHERE toughness = '99';
SELECT name FROM cards WHERE artist = 'Aaron Boyd';
SELECT COUNT(*) FROM cards WHERE borderColor = 'black' AND availability = 'mtgo';
`来包裹代码，所以我得记得在生成的语句前后加上这些符号。 最后，检查一下语法是否正确，确保没有遗漏任何关键字或者标点错误。这样就能写出正确的SQL语句了。 </think>
SELECT DISTINCT layout FROM cards WHERE keywords LIKE '%flying%' ORDER BY layout ASC;
as instructed. </think> To solve this problem, we need to determine how many cards have an original type of "Summon - Angel" and do not have a subtype of "Angel". ### Approach 1. **Understand the Schema**: The database has a table named `cards` which contains information about different cards, including their types and subtypes. 2. **Filter by Type**: We need to filter cards where the type is exactly "Summon - Angel". 3. **Exclude Subtype 'Angel'**: We should exclude any card that has "Angel" as one of its subtypes. 4. **Count the Cards**: Finally, we count how many such cards exist. ### Solution Code
SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
SELECT id FROM cards WHERE duelDeck = 'a';
SELECT edhrecRank FROM cards WHERE frameVersion = '2015';
SELECT cards.artist FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.language = 'Chinese Simplified';
SELECT DISTINCT c.uuid FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.availability = 'paper' AND fd.language = 'Japanese';
SELECT COUNT(DISTINCT c.uuid) AS banned_white_border_count FROM legalities l JOIN cards c ON l.uuid = c.uuid WHERE l.status = 'Banned' AND c.borderColor = 'white';
SELECT c.uuid, fd.language FROM legalities l INNER JOIN cards c ON l.uuid = c.uuid INNER JOIN foreign_data fd ON c.uuid = fd.uuid WHERE l.format = 'Legacy';
SELECT r.*, c.name, c.uuid FROM rulings AS r JOIN cards AS c ON r.uuid = c.uuid WHERE c.name = 'Beacon of Immortality';
SELECT COUNT(*) AS future_frame_version_card_count, status AS legality_status FROM legalities WHERE uuid IN ( SELECT uuid FROM cards WHERE frameVersion = 'future' ) GROUP BY status;
SELECT c.*, l.color FROM cards c JOIN legalities l ON c.uuid = l.card_uuid WHERE l.set_code = 'OGW';
SELECT c.name, c.artist, fd.language FROM cards AS c INNER JOIN sets AS s ON c.setCode = s.code INNER JOIN foreign_data AS fd ON c.uuid = fd.uuid WHERE s.code = '10E' AND c.convertedManaCost = 5;
SELECT c.name, r.date FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.originalType = 'Creature - Elf';
SELECT c.id, c.name AS card_name, c.colors, l.format FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.id BETWEEN 1 AND 20;
SELECT c.name, fd.language FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.originalType = 'Artifact' AND c.colors = 'B';
SELECT DISTINCT c.uuid, c.name, r.date AS ruling_date FROM cards c JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'uncommon' ORDER BY ruling_date ASC LIMIT 3;
. </think> To solve this problem, we need to determine how many cards designed by John Avon have non-powerful foil versions. A foil is considered powerful if both `cardKingdomId` and `cardKingdomFoilId` are not null. ### Approach 1. **Identify Relevant Columns**: We need the `artist` column to filter cards designed by John Avon, and the `cardKingdomId` and `cardKingdomFoilId` columns to determine if a foil is powerful. 2. **Filter Cards by Artist**: Use the `artist` column to select only those cards where the artist is "John Avon". 3. **Determine Non-Powerful Foils**: A foil is non-powerful if either `cardKingdomFoilId` or `cardKingdomId` is null. This means we need to count all cards where at least one of these columns is null. 4. **Count the Cards**: Use the `COUNT(*)` function to count the number of qualifying cards. ### Solution Code
SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL;
SELECT COUNT(*) FROM cards WHERE artist = 'UDON' AND availability = 'mtgo' AND hand = '-1';
SELECT COUNT(*) FROM cards WHERE frameVersion = '1993' AND availability = 'paper' AND hasContentWarning = 1;
SELECT manaCost FROM cards WHERE layout = 'normal' AND frameVersion = '2003' AND borderColor = 'black' AND availability = 'mtgo,paper';
. </think> To calculate the total unconverted mana cost for all cards created by Rob Alexander, we need to sum up the `manaCost` values from the `cards` table where the `artist` is 'Rob Alexander'.
SELECT DISTINCT type, supertypes, subtypes FROM cards WHERE availability = 'arena' ORDER BY type, supertypes, subtypes;
SELECT s.setCode AS Set_Code FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE st.language = 'Spanish';
SELECT ROUND((COUNT(*) FILTER (WHERE isOnlineOnly = 1) / COUNT(*)) * 100, 2) AS percentage FROM cards WHERE frameEffects = 'legendary';
WITH counts AS ( SELECT SUM(CASE WHEN isStorySpotlight = 1 AND isTextless = 0 THEN 1 ELSE 0 END) AS no_text_count, SUM(CASE WHEN isStorySpotlight = 1 THEN 1 ELSE 0 END) AS total_story_spotlight FROM cards ) SELECT no_text_count, total_story_spotlight, CASE WHEN total_story_spotlight = 0 THEN 0 ELSE (no_text_count * 100.0 / total_story_spotlight) END AS percentage FROM counts;
WITH SpanishCards AS ( SELECT COUNT(*) AS spanish_count, COUNT(DISTINCT uuid) AS total_cards FROM foreign_data WHERE language = 'Spanish' ) SELECT (spanish_count * 100.0 / total_cards) AS spanish_percentage, name FROM foreign_data WHERE language = 'Spanish';
SELECT translation AS LanguageName FROM set_translations WHERE setCode = ( SELECT code FROM sets WHERE baseSetSize = 309 );
SELECT COUNT(DISTINCT st.setCode) AS brazilian_portuguese_commander_sets FROM sets s LEFT JOIN set_translations st ON s.setCode = st.setCode WHERE st.language = 'Portuguese (Brasil)' AND s.block = 'Commander';
SELECT cards.id, name, type, legalities.status FROM cards JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.type = 'Creature' AND legalities.status = 'Legal';
SELECT DISTINCT fd.type AS GermanCardType FROM foreign_data fd JOIN cards c ON fd.uuid = c.uuid WHERE fd.language = 'de' AND c.subtypes IS NOT NULL AND c.supertypes IS NOT NULL;
SELECT COUNT(*) FROM cards WHERE ISNULL(power, '') = '*' AND EXISTS ( SELECT 1 FROM foreign_data WHERE foreign_data.uuid = cards.uuid AND (foreign_data.text LIKE '%triggered ability%' OR cards.text LIKE '%triggered ability%') );
SELECT COUNT(*) FROM cards LEFT JOIN rulings ON cards.uuid = rulings.uuid LEFT JOIN legalities ON cards.uuid = legalities.uuid WHERE legalities.format = 'premodern' AND rulings.text LIKE '%This is a triggered mana ability.%' AND cards.side IS NULL;
code blocks as per the user's instruction. </think> To determine if there are any cards by Erica Yang that are available in Pauper format and in paper form, we need to join the `cards` table with the `legalities` table. The `cards` table contains information about each card, including its artist and availability, while the `legalities` table stores the legal formats for each card. Here's the SQL query that retrieves the IDs of such cards:
SELECT cards.artist FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE foreign_data.text = "Das perfekte Gegenmittel zu einer dichten Formation" AND foreign_data.language = "German";
SELECT fd.name AS foreign_name_fr FROM foreign_data fd INNER JOIN cards c ON fd.uuid = c.uuid WHERE fd.language = 'French' AND c.types = 'Creature' AND c.layout = 'normal' AND c.borderColor = 'black' AND c.artist = 'Matthew D. Wilson';
SELECT COUNT(DISTINCT c.id) AS rare_card_count FROM cards c INNER JOIN rulings r ON c.uuid = r.uuid WHERE c.rarity = 'rare' AND r.date = '2007-02-01';
SELECT DISTINCT st.language AS language FROM sets s JOIN set_translations st ON s.setCode = st.setCode WHERE s.baseSetSize = 180 AND s.block = 'Ravnica';
WITH commander_legal AS ( SELECT c.*, l.status FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE l.format = 'Commander' AND l.status = 'Legal' ) SELECT (COUNT(CASE WHEN hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_without_content_warning FROM commander_legal;
SELECT ROUND((COUNT(CASE WHEN language = 'French' AND (power IS NULL OR power = '*') THEN 1 END) * 100 / COUNT(CASE WHEN (power IS NULL OR power = '*') THEN 1 END)), 2) AS percentage FROM foreign_data JOIN cards ON foreign_data.uuid = cards.uuid WHERE power IS NULL OR power = '*';
SELECT ROUND( (COUNT(CASE WHEN language = 'Japanese' AND type = 'expansion' THEN 1 END) * 100.0) / COUNT(CASE WHEN language = 'Japanese' THEN 1 END), 2 ) AS percentage FROM set_translations JOIN sets ON set_translations.setCode = sets.code;
SELECT hasFoil, hasNonFoil, isPromo, isReprint, name, artist FROM cards WHERE artist = 'Daren Bader';
SELECT COUNT(*) FROM cards WHERE borderColor = 'borderless' AND colors IS NOT NULL AND edhrecRank > 12000;
SELECT COUNT(*) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1;
SELECT name, power, promoTypes FROM cards WHERE (power IS NULL OR power = '*') AND promoTypes = 'arenaleague' ORDER BY name ASC LIMIT 3;
SELECT foreign_data.language FROM foreign_data JOIN cards ON foreign_data.uuid = cards.uuid WHERE cards.multiverseId = '149934';
来格式化。 </think>
SELECT ( SELECT COUNT(*) FROM cards WHERE isTextless = 1 AND layout = 'normal' ) / ( SELECT COUNT(*) FROM cards WHERE isTextless = 1 ) * 100 AS proportion_without_text_box_normal_layout
SELECT number FROM cards WHERE side IS NULL AND subtypes LIKE '%Angel%' AND subtypes LIKE '%Wizard%';
SELECT name FROM sets WHERE mtgoCode IS NULL OR mtgoCode = '' ORDER BY name ASC LIMIT 3;
SELECT DISTINCT language FROM set_translations WHERE setCode = 'ARC';
SELECT s.name AS setName, st.translation AS translation FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 5 ORDER BY st.language;
SELECT s.type AS expansion_type, st.translation AS language FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.id = 206 LIMIT 1;
SELECT DISTINCT s.id, s.name FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE st.language = 'italian' AND s.block = 'Shadowmoor' ORDER BY s.name ASC LIMIT 2;
SELECT s.id, s.name FROM sets s WHERE s.isForeignOnly = 0 AND s.isFoilOnly = 1 AND EXISTS ( SELECT 1 FROM set_translations st WHERE st.setCode = s.code AND st.language = 'Japanese' );
SELECT s.code AS.setCode, s.name AS.setName, s.releaseDate AS.setReleaseDate, s.baseSetSize AS.setMaxCards FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE st.language = 'Russian' GROUP BY s.id ORDER BY s.baseSetSize DESC LIMIT 1;
WITH card_language AS ( SELECT c.*, fd.language FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid ) SELECT (COUNT(CASE WHEN isOnlineOnly = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM card_language WHERE language = 'Chinese Simplified';
SELECT COUNT(*) FROM sets s WHERE EXISTS ( SELECT 1 FROM set_translations st WHERE st.setCode = s.code AND st.language = 'Japanese' ) AND (s.mtgoCode IS NULL OR s.mtgoCode = '');
SELECT COUNT(*) AS count, id FROM cards WHERE borderColor = 'black';
SELECT COUNT(*) AS count_of_cards, id FROM cards WHERE frameEffects = 'extendedart';
SELECT name FROM cards WHERE borderColor = 'black' AND isFullArt = 1 LIMIT 1;
SELECT language FROM set_translations WHERE setCode = '174';
SELECT name FROM sets WHERE code = 'ALL';
SELECT language FROM foreign_data WHERE name = 'A Pedra Fellwar';
SELECT code FROM sets WHERE releaseDate = '2007-07-13';
SELECT baseSetSize, code FROM sets WHERE block = 'Masques' OR block = 'Mirage';
SELECT code FROM sets WHERE type = 'expansion';
SELECT fd.name AS foreign_name, c.type FROM foreign_data fd JOIN cards c ON fd.uuid = c.uuid WHERE c.watermark = 'Boros';
SELECT c.type AS card_type, fd.language AS language, fd.flavorText AS flavor_text FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.watermark = 'colorpie';
SELECT (COUNT(c.convertedManaCost = 10) / COUNT(*) ) * 100 AS percentage FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Abyssal Horror';
tags to present the answer correctly. </think> To retrieve the codes of sets with the expansion commander type from the "sets" table, we can use a SELECT statement that filters based on the "type" column. Here's how you can do it:
SELECT fd.name AS foreign_name, c.type AS card_type FROM cards AS c JOIN foreign_data AS fd ON c.uuid = fd.uuid WHERE c.watermark = 'Abzan';
SELECT foreign_data.language, cards.types FROM cards JOIN foreign_data ON cards.uuid = foreign_data.uuid WHERE cards.watermark = 'Azorius';
SELECT COUNT(*) AS total FROM cards WHERE artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL LIMIT 1;
SELECT COUNT(*) AS total_cards FROM cards WHERE availability LIKE '%paper%' AND hand = '3';
SELECT name FROM cards WHERE isTextless = 0;
SELECT manaCost AS unconverted_mana_cost FROM cards WHERE name = 'Ancestor`s Chosen' LIMIT 1;
SELECT COUNT(*) FROM cards WHERE borderColor = 'white' AND (power = '*' OR power IS NULL);
SELECT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL;
SELECT supertypes, subtypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer';
SELECT COALESCE(json_array_elements(cards.purchaseUrls), '') AS website FROM cards WHERE cards.promoTypes = 'bundle';
SELECT COUNT(DISTINCT artist) AS artist_count FROM cards WHERE borderColor = 'black' AND ( INSTR(printings, 'arena') > 0 AND INSTR(printings, 'mtgo') > 0 );
SELECT name, convertedManaCost FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper');
SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer';
SELECT name FROM cards WHERE "frameVersion" = '2003' ORDER BY convertedManaCost DESC, name ASC LIMIT 3;
SELECT translation FROM set_translations WHERE setCode = ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian';
SELECT COUNT(*) AS translation_count FROM set_translations WHERE setCode = ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' );
SELECT c.name AS CardName FROM cards c WHERE EXISTS ( SELECT 1 FROM set_translations st WHERE st.translation = 'Hauptset Zehnte Edition' AND c.printings LIKE '%' || st.setCode || '%' );
SELECT * FROM foreign_data WHERE name = 'Ancestor''s Chosen' AND language = 'Korean';
SELECT COUNT(*) AS NumberOfCards FROM cards c WHERE c.artist = 'Adam Rex' AND c.printings LIKE '%Hauptset Zehnte Edition%';
SELECT s.baseSetSize FROM sets AS s INNER JOIN set_translations AS st ON s.code = st.setCode WHERE st.translation = 'Hauptset Zehnte Edition';
SELECT translation FROM set_translations WHERE setCode = 'Eighth Edition' AND language = 'Chinese Simplified';
SELECT DISTINCT c.name, s.mtgoCode FROM cards c JOIN sets s ON c.setCode = s.code WHERE c.name = 'Angel of Mercy' AND s.mtgoCode IS NOT NULL;
SELECT releaseDate FROM sets WHERE code = ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' );
SELECT type FROM sets WHERE code = (SELECT setCode FROM set_translations WHERE translation = 'Hauptset Zehnte Edition');
SELECT COUNT(DISTINCT s.code) AS italian_ice_age_sets_count FROM sets s LEFT JOIN set_translations st ON s.code = st.setCode WHERE s.block = 'Ice Age' AND st.language = 'Italian' AND st.translation IS NOT NULL;
SELECT CASE WHEN NOT EXISTS ( SELECT 1 FROM cards c LEFT JOIN sets s ON c.setCode = s.code WHERE c.name = 'Adarkar Valkyrie' AND (s.isForeignOnly != 1 OR s.isForeignOnly IS NULL) ) THEN true ELSE false END AS is_only_foreign;
SELECT COUNT(DISTINCT st.setCode) AS NumberOfSets FROM sets s INNER JOIN set_translations st ON s.code = st.setCode WHERE st.language = 'Italian' AND st.translation IS NOT NULL AND s.baseSetSize < 100;
SELECT COUNT(*) FROM cards JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap' AND cards.borderColor = 'black';
SELECT c.name AS CardName, c.convertedManaCost AS ConvertedManaCost FROM cards c JOIN sets s ON c.uuid = s.uuid WHERE s.name = 'Coldsnap' ORDER BY c.convertedManaCost DESC, c.name ASC;
SELECT DISTINCT artist FROM cards WHERE availability = 'COLD' AND artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy');
SELECT c.name AS CardName, c.manaCost AS ManaCost, c.type AS Type, c.rarity AS Rarity, st.translation AS SetName FROM cards c JOIN sets s ON c.setCode = s.code JOIN set_translations st ON s.code = st.setCode WHERE s.code = 'CSP' AND c.number = 4;
SELECT COUNT(*) FROM cards JOIN sets ON cards.uuid = ( SELECT uuid FROM set_translations WHERE setCode = sets.code AND translation = 'Coldsnap' ) WHERE convertedManaCost > 5 AND (power = '*' OR power IS NULL);
SELECT flavorText FROM foreign_data WHERE language = 'Italian' AND name = 'Ancestor''s Chosen';
SELECT DISTINCT language FROM foreign_data WHERE EXISTS ( SELECT 1 FROM cards WHERE cards.uuid = foreign_data.uuid AND cards.name = 'Ancestor''s Chosen' AND foreign_data.flavorText IS NOT NULL );
SELECT type FROM foreign_data WHERE language = 'German' AND name = 'Ancestor''s Chosen';
SELECT r.text AS italian_text_ruling, c.name AS card_name FROM rulings r INNER JOIN cards c ON r.uuid = c.uuid INNER JOIN sets s ON c.setCode = s.code WHERE s.code = 'COLD';
SELECT f.name AS ItalianName FROM cards c JOIN sets s ON c.setCode = s.code LEFT JOIN foreign_data f ON c.uuid = f.uuid AND f.language = 'Italian' WHERE s.name = 'Coldsnap' AND c.convertedManaCost = ( SELECT MAX(convertedManaCost) FROM cards c2 WHERE c2.setCode IN (SELECT code FROM sets WHERE name = 'Coldsnap') );
SELECT r.date FROM rulings AS r INNER JOIN cards AS c ON r.uuid = c.uuid WHERE c.name = 'Reminisce';
SELECT (COUNT(*) FILTER (WHERE convertedManaCost = 7) / COUNT(*)) * 100 AS percentage FROM cards WHERE name = 'Coldsnap';
WITH cte_powerful AS ( SELECT COUNT(*) as powerful_count FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL AND setCode = 'CSP' ), cte_total AS ( SELECT COUNT(*) as total_count FROM cards WHERE setCode = 'CSP' ) SELECT ROUND((powerful_count / total_count) * 100, 2) as percentage FROM cte_powerful, cte_total;
SELECT code FROM sets WHERE releaseDate = '2017-07-14';
SELECT keyruneCode FROM sets WHERE code = 'PKHC';
SELECT mcmId FROM sets WHERE code = 'SS2';
SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09';
SELECT type FROM sets WHERE name = 'From the Vault: Lore';
SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized';
SELECT r.text AS ruling_text, CASE WHEN c.hasContentWarning = 1 THEN 'Yes' ELSE 'No' END AS has_degraded_properties FROM cards c LEFT JOIN rulings r ON c.uuid = r.uuid WHERE c.artist = 'Jim Pavelec' ORDER BY r.date;
SELECT sets.releaseDate FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE cards.name = 'Evacuation';
SELECT s.baseSetSize FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE st.translation = 'Rinascita di Alara';
SELECT s.type AS expansion_type FROM set_translations st JOIN sets s ON st.setCode = s.code WHERE st.language = 'French' AND st.translation = 'Huitième édition';
SELECT fd.name AS french_card_name FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.name = 'Tendo Ice Bridge' AND fd.language = 'French';
SELECT COUNT(*) FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Tenth Edition' OR name = 'Salvat 2011' ) AND translation IS NOT NULL;
SELECT translation AS japaneseSetName FROM set_translations WHERE language = 'Japanese' AND setCode = ( SELECT setCode FROM cards WHERE name = 'Fellwar Stone' );
SELECT c.name AS card_name FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Journey into Nyx Hero''s Path' AND c.convertedManaCost = ( SELECT MAX(c2.convertedManaCost) FROM cards c2 JOIN sets s2 ON c2.setCode = s2.code WHERE s2.name = 'Journey into Nyx Hero''s Path' );
SELECT sets.releaseDate FROM sets JOIN set_translations ON sets.code = set_translations.setCode WHERE set_translations.translation = 'Ola de frío';
SELECT sets.type AS expansion_type FROM cards JOIN sets ON cards.setCode = sets.code WHERE cards.name = 'Samite Pilgrim';
SELECT COUNT(*) FROM cards JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'World Championship Decks 2004' AND cards.convertedManaCost = 3;
SELECT translation FROM set_translations WHERE language = 'Chinese Simplified' AND setCode = 'Mirrodin';
SELECT (COUNT(*) FILTER (WHERE sets.isNonFoilOnly = 1) / COUNT(*)) * 100 AS japanese_non_foil_percentage FROM foreign_data JOIN cards USING(uuid) JOIN sets ON cards.setCode = sets.code WHERE foreign_data.language = 'Japanese';
WITH brazil_portuguese AS ( SELECT c.uuid, c.isOnlineOnly, fd.language FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE fd.language = 'Portuguese (Brazil)' ) SELECT ROUND( (SUM(isOnlineOnly) * 100.0 / NULLIF(COUNT(uuid), 0)), 2 ) AS percentage_online_only_brazil_portuguese FROM brazil_portuguese;
SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1;
SELECT id FROM sets WHERE baseSetSize = (SELECT MAX(baseSetSize) FROM sets) LIMIT 1;
SELECT artist FROM cards WHERE convertedManaCost = ( SELECT MAX(convertedManaCost) FROM cards WHERE side IS NULL ) AND side IS NULL;
WITH frame_effect_counts AS ( SELECT frameEffects, COUNT(*) as count FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ) SELECT frameEffects, count FROM frame_effect_counts WHERE count = (SELECT MAX(count) FROM frame_effect_counts);
SELECT COUNT(*) AS count FROM cards WHERE (power IS NULL OR power = '*') AND hasFoil = 0 AND duelDeck = 'a';
SELECT id FROM sets WHERE totalSetSize = (SELECT MAX(totalSetSize) FROM sets WHERE type = 'commander') AND type = 'commander';
SELECT DISTINCT c.id, c.name, c.manaCost, c.convertedManaCost FROM cards c INNER JOIN legalities l ON c.uuid = l.uuid WHERE l.format = 'duel' GROUP BY c.id, c.manaCost ORDER BY c.convertedManaCost DESC LIMIT 10;
SELECT MIN(c.originalReleaseDate) AS oldest_release_date, c.name AS card_name, l.format FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.rarity = 'mythic' AND l.status = 'legal' GROUP BY c.uuid, l.format;
SELECT COUNT(DISTINCT c.uuid) AS french_french_count FROM cards c INNER JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.artist = 'Volkan Baǵa' AND fd.language = 'French';
SELECT COUNT(*) FROM cards WHERE rarity = 'rare' AND types = 'Enchantment' AND name = 'Abundance' AND uuid IN ( SELECT l.uuid FROM legalities l WHERE status = 'Legal' GROUP BY l.uuid HAVING MIN(status) = 'Legal' );
WITH BannedCounts AS ( SELECT l.format, COUNT(*) as banned_count FROM legalities l WHERE l.status = 'Banned' GROUP BY l.format ), MaxBanCount AS ( SELECT MAX(banned_count) as max_ban FROM BannedCounts ) SELECT c.name, bc.format FROM cards c JOIN legalities l ON c.uuid = l.uuid JOIN BannedCounts bc ON l.format = bc.format JOIN MaxBanCount mbc ON bc.banned_count = mbc.max_ban WHERE l.status = 'Banned';
SELECT language FROM set_translations WHERE setCode = ( SELECT code FROM sets WHERE name = 'Battlebond' );
WITH artist_count AS ( SELECT artist, COUNT(DISTINCT uuid) as card_count FROM cards WHERE artist IS NOT NULL GROUP BY artist ) SELECT a.artist, l.format FROM artist_count ac JOIN cards c ON ac.artist = c.artist LEFT JOIN legalities l ON c.uuid = l.uuid WHERE ac.card_count = (SELECT MIN(card_count) FROM artist_count) AND l.format IS NOT NULL GROUP BY a.artist, l.format;
SELECT legalities.status FROM cards JOIN legalities ON cards.uuid = legalities.uuid WHERE cards.frameVersion = '1997' AND cards.artist = 'D. Alexander Gregory' AND legalities.format = 'legacy' AND cards.hasContentWarning = 1;
SELECT c.name, l.format FROM cards AS c INNER JOIN legalities AS l ON c.uuid = l.uuid WHERE c.edhrecRank = 1 AND l.status = 'Banned';
WITH yearly_counts AS ( SELECT strftime('%Y', releaseDate) AS year, COUNT(*) AS sets_released FROM sets WHERE strftime('%Y-%m-%d', releaseDate) BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY year ), average_sets AS ( SELECT AVG(sets_released) AS annual_average FROM yearly_counts ) common_language AS ( SELECT language, COUNT(*) AS language_count FROM set_translations WHERE strftime('%Y-%m-%d', releaseDate) BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY language ORDER BY language_count DESC, language ASC ) SELECT annual_average, (SELECT language FROM common_language LIMIT 1) AS most_common_language FROM average_sets, common_language;
SELECT DISTINCT artist FROM cards WHERE borderColor = 'black' AND availability = 'arena';
SELECT uuid FROM legalities WHERE format = 'oldschool' AND status IN ('banned', 'restricted');
SELECT COUNT(*) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper';
tags for clarity. </think> To find the rulings for cards designed by Kev Walker, we need to: 1. Join the `rulings` table with the `cards` table on their shared `uuid` 2. Filter where the `artist` field in `cards` is 'Kev Walker' 3. Select the ruling date and text 4. Order the results by date in descending order
SELECT c.name AS CardName, l.format AS LegalFormat FROM cards c JOIN legalities l ON c.uuid = l.card_uuid WHERE c.set_code = ( SELECT code FROM sets WHERE name = 'Hour of Devastation' ) AND l.status = 'Legal';
SELECT DISTINCT s.name FROM sets s WHERE EXISTS ( SELECT 1 FROM set_translations st WHERE st.setCode = s.code AND st.language = 'Korean' ) AND NOT EXISTS ( SELECT 1 FROM set_translations st WHERE st.setCode = s.code AND st.language LIKE '%Japanese%' );

SELECT CASE WHEN (SELECT Reputation FROM users WHERE DisplayName = 'Harlan') > (SELECT Reputation FROM users WHERE DisplayName = 'Jarrod Dixon') THEN 'Harlan' ELSE 'Jarrod Dixon' END AS HigherReputationUser FROM dual;
SELECT DisplayName FROM users WHERE strftime('%Y', CreationDate) = '2011';
SELECT COUNT(*) FROM users WHERE LastAccessDate > '2014-09-01';
SELECT DisplayName FROM users WHERE Views = (SELECT MAX(Views) FROM users)
SELECT COUNT(*) FROM users WHERE UpVotes > 100 AND DownVotes > 1;
SELECT COUNT(*) FROM users WHERE DATEPART(year, CreationDate) > 2013 AND Views > 10;
SELECT COUNT(p.Id) AS NumberOfPosts FROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie';
SELECT p.Title FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie';
SELECT p.Title, u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Title = 'Eliciting priors from experts';
SELECT p.Title AS Title FROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie' GROUP BY p.Id ORDER BY p.ViewCount DESC LIMIT 1;
SELECT COALESCE(u.OwnerDisplayName, '') AS MostValuablePostOwner FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.FavoriteCount = ( SELECT MAX(p2.FavoriteCount) FROM posts p2 )
SELECT SUM(posts.CommentCount) AS TotalComments FROM posts WHERE posts.OwnerDisplayName = 'csgillespie';
SELECT MAX(AnswerCount) AS MaxAnswers FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie';
SELECT u.DisplayName AS UserName FROM posts p JOIN users u ON p.LastEditorUserId = u.Id WHERE p.Title = "Examples for teaching: Correlation does not mean causation" LIMIT 1;
SELECT COUNT(*) FROM posts JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'csgillespie' AND posts.ParentId IS NULL;
SELECT u.DisplayName AS DisplayName FROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE p.ClosedDate IS NOT NULL;
SELECT COUNT(*) FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.Age > 65 AND posts.Score >= 20;
SELECT u.Location FROM posts p INNER JOIN users u ON p.OwnerUserId = u.Id WHERE p.Title = 'Eliciting priors from experts';
SELECT t.TagName, p.Body, t.ExcerptPostId, p.CreationDate, p.Title FROM tags AS t INNER JOIN posts AS p ON t.ExcerptPostId = p.Id WHERE t.TagName = 'bayesian';
SELECT p.Body FROM posts p JOIN tags t ON p.Id = t.ExcerptPostId WHERE t.Count = (SELECT MAX(t2.Count) FROM tags t2)
SELECT COUNT(*) AS BadgeCount FROM badges JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'csgillespie';
SELECT DISTINCT badges.Name AS BadgeName FROM badges JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'csgillespie' ORDER BY BadgeName;
SELECT COUNT(*) FROM badges WHERE UserId IN (SELECT Id FROM users WHERE DisplayName = 'csgillespie') AND YEAR(Date) = 2011;
SELECT u.DisplayName FROM users u WHERE u.UserId = ( SELECT UserId FROM ( SELECT UserId, COUNT(*) AS BadgeCount FROM badges WHERE UserId IS NOT NULL GROUP BY UserId ORDER BY BadgeCount DESC LIMIT 1 ) AS subquery );
SELECT AVG(p.Score) AS AverageScore FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'csgillespie';
SELECT u.DisplayName AS UserName, AVG(COUNT(badges.Id)) OVER (PARTITION BY badges.UserId) AS AverageBadges FROM badges JOIN users u ON badges.UserId = u.Id WHERE u.Views > 200 GROUP BY badges.UserId;
WITH Total AS ( SELECT COUNT(p.Id) AS TotalPosts FROM posts p WHERE p.Score > 5 ), ElderCount AS ( SELECT COUNT(p.Id) AS ElderPosts FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Score > 5 AND u.Age > 65 ) SELECT (ElderCount.ElderPosts * 100.0 / Total.TotalPosts) AS Percentage FROM Total, ElderCount;
SELECT COUNT(*) AS TotalVotes FROM votes WHERE UserId = 58 AND CreationDate = '2010-07-19';
SELECT DATE(votes.CreationDate) AS CreationDate, COUNT(*) AS TotalVotes FROM votes GROUP BY DATE(votes.CreationDate) ORDER BY TotalVotes DESC LIMIT 1;
SELECT COUNT(*) AS NumberOfRevivals FROM badges WHERE Name = 'Revival';
SELECT p.Title AS Title FROM posts p INNER JOIN comments c ON p.Id = c.PostId WHERE c.Score = ( SELECT MAX(c2.Score) FROM comments c2 )
SELECT COUNT(*) AS CommentCount FROM comments WHERE PostId = ( SELECT Id FROM posts WHERE ViewCount = 1910 );
SELECT c.PostId FROM comments AS c WHERE c.UserId = 3025 AND c.CreationDate = '2014-04-23 20:29:39.0';
SELECT c.Text AS CommentText FROM posts p JOIN comments c ON p.Id = c.PostId WHERE p.ParentId = 107829 AND p.CommentCount = 1;
SELECT c.CreationDate, p.Title, p.ClosedDate FROM comments AS c JOIN posts AS p ON c.PostId = p.Id WHERE c.UserId = 23853 AND c.CreationDate = '2013-07-12 09:08:18.0'
SELECT u.Reputation FROM users AS u JOIN posts AS p ON u.Id = p.OwnerUserId WHERE p.Id = 65041;
SELECT COUNT(*) AS PostCount FROM posts WHERE OwnerUserId = ( SELECT Id FROM users WHERE DisplayName = 'Tiago Pasqualini' );

SELECT p.Title, SUM(v.VoteTypeId) AS TotalVotes FROM posts p JOIN votes v ON p.PostId = v.PostId WHERE p.Title LIKE '%数据可视化%' GROUP BY p.PostId, p.Title;
SELECT DISTINCT u.DisplayName, b.Name FROM users u JOIN badges b ON u.Id = b.UserId WHERE u.DisplayName = 'DatEpicCoderGuyWhoPrograms' ORDER BY u.DisplayName;
WITH post_count AS ( SELECT COUNT(Id) as posts FROM posts WHERE OwnerUserId = 24 ), vote_count AS ( SELECT COUNT(Id) as votes FROM votes WHERE UserId = 24 ) SELECT (posts / votes) as PostToVoteRatio FROM post_count, vote_count;
SELECT ViewCount FROM posts WHERE Title = ' "Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer" ' LIMIT 1;
代码块包裹生成的语句，并且正确无误地呈现出来。 </think>
SELECT DisplayName FROM users WHERE WebsiteUrl = 'http://stackoverflow.com';
SELECT b.Name AS BadgeName FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'SilentGhost';
SELECT c.UserId AS UserName, u.DisplayName AS ThankedUser FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Text LIKE 'thank you user%d' ORDER BY c.CreationDate DESC;
SELECT c.PostId, c.Score, c.Text, c.CreationDate FROM comments AS c JOIN users AS u ON c.UserId = u.Id WHERE u.UserDisplayName = 'A Lion.';
SELECT u.DisplayName, u.Reputation FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.Title = 'Understanding what Dassault iSight is doing?';
SELECT c.Text AS CommentText FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.Title = 'How does gentle boosting differ from AdaBoost?';
SELECT DISTINCT u.DisplayName FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Necromancer' LIMIT 10;
SELECT u.DisplayName AS EditorName FROM posts p JOIN users u ON p.LastEditorUserId = u.Id WHERE p.Title = 'Open source tools for visualizing multi-dimensional data';
SELECT p.Title FROM posts p JOIN users u ON p.LastEditorUserId = u.Id WHERE u.DisplayName = 'Vebjorn Ljosa' LIMIT 100;
SELECT SUM(p.Score) AS TotalScore, u.WebsiteUrl FROM posts p LEFT JOIN users u ON p.LastEditorUserId = u.UserId WHERE u.DisplayName = 'Yevgeny';
SELECT c.UserId, c.Text FROM comments c JOIN postHistory ph ON c.UserId = ph.UserId WHERE ph.PostId = ( SELECT Id FROM posts WHERE Title = 'Why square the difference instead of taking the absolute value in standard deviation?' );
SELECT SUM(IFNULL(votes.BountyAmount, 0)) AS TotalBounty FROM posts LEFT JOIN votes ON posts.Id = votes.PostId WHERE posts.Title LIKE '%data%' ORDER BY posts.Id ASC;
SELECT u.DisplayName, p.Title, v.CreationDate FROM votes v JOIN posts p ON v.PostId = p.Id JOIN users u ON v.UserId = u.Id WHERE v.BountyAmount = 50 AND p.Title LIKE '%variance%';
SELECT p.Title AS Title, p.Body AS Comment, AVG(p.ViewCount) AS AverageViewCount FROM posts p JOIN tags t ON p.Id = t.ExcerptPostId OR p.Id = t.WikiPostId WHERE t.TagName = 'humor' GROUP BY p.Id;
SELECT COUNT(*) FROM comments WHERE UserId = 13;
SELECT Id, MAX(Reputation) AS HighestReputation FROM users;
SELECT UserId FROM users WHERE Views = ( SELECT MIN(Views) FROM users WHERE Views IS NOT NULL );
SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Supporter' AND DATEPART(year, Date) = 2011;
SELECT COUNT(UserId) AS NumberOfUsersWithMoreThanFiveBadges FROM badges WHERE UserId IS NOT NULL GROUP BY UserId HAVING COUNT(*) > 5;
SELECT COUNT(*) FROM users WHERE Location = 'New York' AND EXISTS ( SELECT * FROM badges WHERE UserId = users.UserId AND Name = 'Supporter' ) AND EXISTS ( SELECT * FROM badges WHERE UserId = users.UserId AND Name = 'Teacher' );
SELECT p.OwnerUserId AS UserId, u.Reputation FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.PostId = 1;
WITH ValidPostIds AS ( SELECT ph.PostId FROM postHistory ph GROUP BY ph.PostId HAVING COUNT(*) = 1 ) SELECT u.UserId, u.Views FROM users u WHERE u.Views >= 1000 AND NOT EXISTS ( SELECT 1 FROM posts p WHERE p.OwnerUserId = u.UserId AND p.PostId NOT IN (SELECT PostId FROM ValidPostIds) );
SELECT b.UserId, b.Name as BadgeName FROM badges b WHERE b.UserId IN ( SELECT c.UserId FROM comments c GROUP BY c.UserId HAVING COUNT(c.Id) = ( SELECT MAX(commentCount) FROM ( SELECT COUNT(c2.Id) AS commentCount, c2.UserId FROM comments c2 GROUP BY c2.UserId ) AS commentCounts ) );
SELECT COUNT(DISTINCT u.Id) AS NumberOfIndianTeacherUsers FROM users u INNER JOIN badges b ON u.Id = b.UserId WHERE u.Location = 'India' AND b.Name = 'Teacher';
WITH student_badges AS ( SELECT YEAR(Date) AS Year, COUNT(*) AS Count FROM badges WHERE Name = 'Student' GROUP BY YEAR(Date) ), total_students AS ( SELECT COUNT(*) AS Total FROM badges WHERE Name = 'Student' ) SELECT (COUNT_2010 / Total * 100) - (COUNT_2011 / Total * 100) AS PercentageDifference FROM student_badges CROSS JOIN total_students WHERE Year IN (2010, 2011);
SELECT DISTINCT PostHistoryTypeId FROM postHistory WHERE PostId = 3720 UNION SELECT COUNT(DISTINCT UserId) AS UniqueCommenters FROM comments WHERE PostId = 3720;
SELECT p.*, p.ViewCount AS Popularity, CASE WHEN pl.PostId = 61217 THEN 'Main Post' ELSE 'Related Post' END AS IsMainPost FROM posts p LEFT JOIN postLinks pl ON p.Id = pl.PostId OR p.Id = pl.RelatedPostId WHERE pl.PostId = 61217 OR pl.RelatedPostId = 61217;
SELECT p.Score, pl.LinkTypeId FROM posts AS p LEFT JOIN postLinks AS pl ON p.Id = pl.PostId WHERE p.Id = 395;
SELECT posts.Id AS PostID, posts.OwnerUserId AS UserID FROM posts WHERE posts.Score > 60;
SELECT SUM(FavoriteCount) AS TotalFavorites FROM posts WHERE OwnerUserId = 686 AND YEAR(CreationDate) = 2011;
SELECT (SUM(UpVotes) / COUNT(UserId)) AS Avg_Upvotes, (SUM(Age) / COUNT(UserId)) AS Avg_UserAge FROM users WHERE UserId IN ( SELECT OwnerUserId FROM posts GROUP BY OwnerUserId HAVING COUNT(OwnerId) > 10 ) GROUP BY UserId;
SELECT COUNT(DISTINCT UserId) AS AnnouncerBadgeCount FROM badges WHERE Name = 'Announcer';
SELECT Name FROM badges WHERE Date = '2010-07-19 19:39:08.0';
SELECT COUNT(*) FROM comments WHERE Score > 60;
SELECT Text FROM comments WHERE CreationDate = '2010-07-19 19:25:47';
SELECT COUNT(Id) FROM posts WHERE Score = 10;
SELECT Name FROM badges WHERE UserId = (SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1)
SELECT users.Reputation FROM badges JOIN users ON badges.UserId = users.Id WHERE badges.Date = '2010-07-19 19:39:08.0';
SELECT badges.Name FROM badges JOIN users ON badges.UserId = users.Id WHERE users.DisplayName = 'Pierre';
SELECT b.Date AS BadgeDate, u.UserId FROM badges b LEFT JOIN users u ON b.UserId = u.UserId WHERE u.Location = 'Rochester, NY';
SELECT (COUNT(DISTINCT b.UserId) / COUNT(DISTINCT u.Id)) * 100 AS TeacherBadgePercentage FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Teacher';
SELECT (COUNT(CASE WHEN u.Age BETWEEN 13 AND 18 THEN u.UserId END) / COUNT(DISTINCT u.UserId)) * 100 AS OrganizerTeenPercentage FROM badges b JOIN users u ON b.UserId = u.Id WHERE b.Name = 'Organizer';
SELECT c.Score FROM comments AS c INNER JOIN posts AS p ON c.PostId = p.Id WHERE p.CreationDate = '2010-07-19 19:19:56.0' AND c.Score IS NOT NULL;
SELECT c.Text FROM comments AS c JOIN posts AS p ON c.PostId = p.Id WHERE p.CreationDate = '2010-07-19 19:37:33.0';
SELECT u.Age FROM users AS u INNER JOIN badges AS b ON u.Id = b.UserId WHERE u.Location = 'Vienna, Austria';
SELECT COUNT(DISTINCT badges.UserId) AS AdultSupportersCount FROM badges JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Supporter' AND users.Age BETWEEN 19 AND 65;
SELECT u.Views FROM badges AS b INNER JOIN users AS u ON b.UserId = u.Id WHERE b.Date = '2010-07-19 19:39:08.0';
SELECT DISTINCT b.Name AS BadgeName FROM badges b WHERE b.UserId IN ( SELECT u.Id FROM users u WHERE u.Reputation = (SELECT MIN(Reputation) FROM users) ) ORDER BY BadgeName;
SELECT b.Name AS BadgeName FROM badges AS b JOIN users AS u ON b.UserId = u.Id WHERE u.DisplayName = 'Sharpie';
SELECT COUNT(*) FROM badges JOIN users ON badges.UserId = users.Id WHERE badges.Name = 'Supporter' AND users.Age > 65;
SELECT DisplayName FROM users WHERE Id = 30;
SELECT COUNT(*) FROM users WHERE Location = 'New York';
SELECT COUNT(*) FROM votes WHERE YEAR(CreationDate) = 2010;
SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65;
WITH MaxViews AS ( SELECT MAX(Views) AS MaxView FROM users ) SELECT u.DisplayName, u.Views FROM users u WHERE u.Views = (SELECT MaxView FROM MaxViews) ORDER BY u.DisplayName;
SELECT (COUNT(CASE WHEN YEAR(CreationDate) = 2010 THEN Id END)) / (COUNT(CASE WHEN YEAR(CreationDate) = 2011 THEN Id END)) AS vote_ratio FROM votes;
SELECT DISTINCT tags.TagName ASTagName FROM users INNER JOIN posts ON users.Id = posts.OwnerUserId INNER JOIN tags ON tags.ExcerptPostId = posts.Id OR tags.WikiPostId = posts.Id WHERE users.DisplayName = 'John Salvatier';
SELECT COUNT(*) AS NumberOfPosts FROM posts INNER JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'Daniel Vassallo';
SELECT COUNT(*) AS TotalVotes FROM votes WHERE UserId = ( SELECT Id FROM users WHERE DisplayName = 'Harlan' );
SELECT posts.Id AS PostId, MAX(posts.AnswerCount) AS MaxAnswerCount FROM posts JOIN users ON posts.OwnerUserId = users.Id WHERE users.DisplayName = 'slashnick' GROUP BY posts.Id;
WITH Harvey_ViewCount AS ( SELECT SUM(ViewCount) AS HarveyViews FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky' ), Noah_ViewCount AS ( SELECT SUM(ViewCount) AS NoahViews FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Noah Snyder' ) SELECT HarveyViews, NoahViews, CASE WHEN HarveyViews > NoahViews THEN 'Harvey Motulsky has higher popularity' WHEN NoahViews > HarveyViews THEN 'Noah Snyder has higher popularity' ELSE 'Both have equal popularity' END AS Result FROM Harvey_ViewCount, Noah_ViewCount;
SELECT COUNT(*) FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Matt Parker' AND p.PostId > 4;
SELECT COUNT(*) AS NegativeCommentsCount FROM comments c WHERE UserId = ( SELECT Id FROM users WHERE DisplayName = 'Neil McGuigan' ) AND Score < 60;
SELECT DISTINCT tags.TagName FROM users, posts, tags WHERE users.DisplayName = 'Mark Meckes' AND posts.OwnerUserId = users.Id AND (tags.ExcerptPostId = posts.Id OR tags.WikiPostId = posts.Id) AND posts.CommentCount = 0;
SELECT DISTINCT u.DisplayName FROM badges AS b JOIN users AS u ON b.UserId = u.Id WHERE b.Name = 'Organizer';
WITH community_posts AS ( SELECT p.Id, p.OwnerUserId FROM posts p WHERE p.OwnerDisplayName = 'Community' ), r_tagged_posts AS ( SELECT t.PostId FROM tags t WHERE t.TagName = 'r' ) SELECT (COUNT(DISTINCT r.PostId) / COUNT(DISTINCT c.Id)) * 100 AS percentage FROM community_posts c LEFT JOIN r_tagged_posts r ON c.Id = r.PostId;
SELECT (SUM(CASE WHEN u.DisplayName = 'Mornington' THEN p.ViewCount ELSE 0 END) - SUM(CASE WHEN u.DisplayName = 'Amos' THEN p.ViewCount ELSE 0 END)) AS view_count_difference FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName IN ('Mornington', 'Amos');
SELECT COUNT(DISTINCT UserId) AS CommentatorBadgeUsersCount FROM badges WHERE Name = 'Commentator' AND DATEPART(year, Date) = 2014;
SELECT COUNT(Id) FROM posts WHERE CreationDate BETWEEN '2010-07-21 00:00:00' AND '2010-07-21 23:59:59';
SELECT DisplayName, Age FROM users ORDER BY Views DESC LIMIT 1;
SELECT LastEditDate, LastEditorUserId FROM posts WHERE Title = 'Detecting a given face in a database of facial images';
代码块。 </think>
SELECT c.PostId, p.Title AS PostTitle, u.DisplayName AS UserName FROM comments c JOIN posts p ON c.PostId = p.Id JOIN users u ON c.UserId = u.Id WHERE c.Score > 60;
SELECT b.Name FROM badges AS b JOIN users AS u ON b.UserId = u.Id WHERE year(b.Date) = 2011 AND u.Location = 'North Pole';
SELECT u.DisplayName, u.WebsiteUrl FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.FavoriteCount > 150;
SELECT AnswerCount, CommentCount, LastEditDate FROM posts WHERE Title = "What is the best introductory Bayesian statistics textbook?";
SELECT u.LastAccessDate, u.Location FROM users AS u INNER JOIN badges AS b ON u.Id = b.UserId WHERE b.Name = 'Outliers';
SELECT DISTINCT p.Title AS RelatedPostTitle FROM posts p JOIN tags t ON p.Id = t.ExcerptPostId OR p.Id = t.WikiPostId WHERE t.TagName IN ('database', 'monitoring', 'time-series') AND p.PostTypeId = 'question' ORDER BY p.CreationDate DESC;
SELECT p.Id AS PostId, b.Name AS BadgeName FROM users u INNER JOIN badges b ON u.UserId = b.UserId INNER JOIN posts p ON u.UserId = p.OwnerUserId WHERE u.DisplayName = 'Samuel' AND YEAR(b.Date) = 2013 AND YEAR(p.CreationDate) = 2013;
SELECT u.DisplayName AS OwnerDisplayName FROM users u INNER JOIN posts p ON u.Id = p.OwnerUserId WHERE p.ViewCount = ( SELECT MAX(p2.ViewCount) FROM posts p2 ) LIMIT 1;
SELECT u.DisplayName, u.Location FROM users u INNER JOIN posts p ON u.Id = p.OwnerUserId INNER JOIN tags t ON p.Id = t.ExcerptPostId WHERE t.TagName = 'hypothesis-testing' AND t.ExcerptPostId IS NOT NULL;
SELECT RelatedPostId, LinkTypeId FROM postLinks WHERE PostId = ( SELECT Id FROM posts WHERE Title = 'What are principal component scores?' );
SELECT p2.OwnerDisplayName FROM posts p1 JOIN posts p2 ON p1.ParentId = p2.Id WHERE p1.ParentId IS NOT NULL AND p1.Score = ( SELECT MAX(p3.Score) FROM posts p3 WHERE p3.ParentId IS NOT NULL );
WITH MaxBounty AS ( SELECT MAX(BountyAmount) AS MaxBountyAmount FROM votes WHERE VoteTypeId = 8 ) SELECT u.DisplayName, u.WebsiteUrl FROM votes v JOIN users u ON v.UserId = u.Id WHERE v.VoteTypeId = 8 AND v.BountyAmount = (SELECT MaxBountyAmount FROM MaxBounty) ORDER BY v.BountyAmount DESC;
SELECT Title FROM posts ORDER BY ViewCount DESC LIMIT 5;
SELECT COUNT(*) FROM tags WHERE Count BETWEEN 5000 AND 7000;
SELECT p.OwnerUserId AS OwnerUserId, u.DisplayName AS OwnerDisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.FavoriteCount = (SELECT MAX(p2.FavoriteCount) FROM posts p2)
SELECT DisplayName AS UserName, DATEDIFF(year, CreationDate, GETDATE()) AS Age FROM users WHERE Reputation = ( SELECT MAX(Reputation) FROM users ) ORDER BY Reputation DESC;
SELECT COUNT(*) FROM posts INNER JOIN votes ON posts.Id = votes.PostId WHERE YEAR(posts.CreationDate) = 2011 AND votes.BountyAmount = 50;
code
SELECT SUM(Score) AS TotalScore FROM posts WHERE DATE(LasActivityDate) >= '2010-07-19';
SELECT DIVIDE(COUNT(postLinks.Id), 12) AS AverageMonthlyLinks FROM postLinks JOIN posts ON postLinks.PostId = posts.Id WHERE YEAR(postLinks.CreationDate) = 2010 AND posts.AnswerCount <= 2;
SELECT TOP 1 p.Id AS MostValuablePostId FROM posts p JOIN votes v ON p.Id = v.PostId WHERE v.UserId = 1465 ORDER BY p.FavoriteCount DESC;
SELECT p.Title FROM posts p JOIN postLinks pl ON p.Id = pl.PostId WHERE pl.CreationDate = ( SELECT MIN(pl2.CreationDate) FROM postLinks pl2 );
SELECT u.DisplayName AS [Display Name] FROM users u LEFT JOIN badges b ON u.Id = b.UserId GROUP BY u.Id, u.DisplayName HAVING COUNT(b.Name) = ( SELECT MAX(cnt) FROM ( SELECT COUNT(*) as cnt FROM badges GROUP BY UserId ) AS subquery );
SELECT MIN(v.CreationDate) AS FirstVoteDate FROM votes v JOIN users u ON v.UserId = u.Id WHERE u.DisplayName = 'chl';
SELECT MIN(ph.CreationDate) AS FirstPostDate FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE u.Age = (SELECT MIN(u2.Age) FROM users u2)
SELECT u.DisplayName FROM users u WHERE u.Id = ( SELECT UserId FROM badges WHERE Name = 'Autobiographer' ORDER BY Date ASC LIMIT 1 );
SELECT COUNT(*) AS NumberOfUsers FROM users INNER JOIN posts ON users.Id = posts.OwnerUserId WHERE users.Location = 'United Kingdom' GROUP BY posts.OwnerUserId HAVING SUM(posts.FavoriteCount) >= 4;
SELECT AVG(COUNT(*)) AS average_votes FROM votes WHERE UserId IN ( SELECT Id FROM users WHERE Age = (SELECT MAX(Age) FROM users) );
SELECT DisplayName FROM users ORDER BY Reputation DESC LIMIT 1;
SELECT COUNT(*) FROM users WHERE Reputation > 2000 AND Views > 1000;
SELECT DisplayName FROM users WHERE Age BETWEEN 19 AND 65;
SELECT COUNT(p.Id) AS PostCount FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Jay Stevens' AND YEAR(p.CreationDate) = 2010;
SELECT p.Id, p.Title FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky' ORDER BY p.ViewCount DESC LIMIT 1;
SELECT Id, Title FROM posts WHERE Score = (SELECT MAX(Score) FROM posts)
SELECT AVG(p.Score) AS AverageScore FROM users u JOIN posts p ON u.Id = p.OwnerUserId WHERE u.DisplayName = 'Stephen Turner';
SELECT u.DisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE p.ViewCount > 20000 AND YEAR(p.CreationDate) = 2011;
SELECT TOP 1 p.Id, u.DisplayName AS OwnerDisplayName FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE YEAR(p.CreationDate) = 2010 ORDER BY p.FavoriteCount DESC;
SELECT (COUNT(p.Id) / (SELECT COUNT(*) FROM posts WHERE YEAR(CreationDate) = 2011)) * 100 AS Percentage FROM posts p JOIN users u ON p.OwnerUserId = u.Id WHERE YEAR(p.CreationDate) = 2011 AND u.Reputation > 1000;
SELECT ROUND( (COUNT(*) WHERE Age BETWEEN 13 AND 18) / COUNT(*) * 100, 2 ) AS percentage FROM users;
SELECT p.ViewCount, u.DisplayName FROM posts AS p JOIN users AS u ON p.OwnerUserId = u.Id WHERE p.Body LIKE '%Computer Game Datasets%';
SELECT COUNT(*) FROM posts WHERE ViewCount > ( SELECT AVG(ViewCount) FROM posts );
SELECT COUNT(*) AS NumberOfComments FROM comments c WHERE c.PostId = ( SELECT p.Id FROM posts p WHERE p.Score = (SELECT MAX(p2.Score) FROM posts p2) );
SELECT COUNT(*) FROM posts WHERE ViewCount > 35000 AND CommentCount = 0;
SELECT u.DisplayName, u.Location FROM users u WHERE u.Id = ( SELECT ph.UserId FROM postHistory ph WHERE ph.PostId = 183 ORDER BY ph.CreationDate DESC LIMIT 1 );
SELECT TOP 1 b.Name AS MostRecentBadge FROM badges b JOIN users u ON b.UserId = u.Id WHERE u.DisplayName = 'Emmett' ORDER BY b.Date DESC;
SELECT COUNT(*) FROM users WHERE Age BETWEEN 19 AND 65 AND UpVotes > 5000;
SELECT MIN(badge.Date - user.CreationDate) AS DaysToBadge FROM badges badge JOIN users user ON badge.UserId = user.Id WHERE user.DisplayName = 'Zolomon';
WITH latest_user AS ( SELECT Id FROM users ORDER BY CreationDate DESC LIMIT 1 ) SELECT (SELECT COUNT(*) FROM posts WHERE UserId = lu.Id) as post_count, (SELECT COUNT(*) FROM comments WHERE UserId = lu.Id) as comment_count FROM latest_user lu;
SELECT c.Text, u.UserDisplayName FROM comments AS c JOIN posts AS p ON c.PostId = p.Id JOIN users AS u ON c.UserId = u.Id WHERE p.Title = 'Analysing wind data with R' ORDER BY c.CreationDate DESC LIMIT 10;
SELECT COUNT(DISTINCT UserId) FROM badges WHERE Name = 'Citizen Patrol';
SELECT COUNT(DISTINCT p.Id) AS CareersTagPostsCount FROM tags t JOIN posts p ON t.ExcerptPostId = p.Id OR t.WikiPostId = p.Id WHERE t.TagName = 'careers';
SELECT Reputation, Views FROM users WHERE DisplayName = 'Jarrod Dixon';
SELECT p.AnswerCount AS NumberOfAnswers, COUNT(c.Id) AS NumberOfComments FROM posts p LEFT JOIN comments c ON c.PostId = p.Id WHERE p.Title = 'Clustering 1D data';
SELECT CreationDate FROM users WHERE DisplayName = 'IrishStat';
SELECT COUNT(DISTINCT v.PostId) AS NumberOfPostsWithBountyOver30 FROM votes v JOIN posts p ON v.PostId = p.Id WHERE v.BountyAmount >= 30;
WITH max_reputation_user AS ( SELECT u.Id AS UserId, MAX(u.Reputation) AS MaxReputation FROM users u GROUP BY u.Id ORDER BY MaxReputation DESC LIMIT 1 ) SELECT (COUNT(p.Id) / CAST(COUNT(*) AS FLOAT)) * 100 AS PercentageAbove50 FROM posts p JOIN max_reputation_user mru ON p.OwnerUserId = mru.UserId WHERE p.Score > 50;
SELECT COUNT(*) FROM Posts WHERE Score < 20;
代码块。 </think> 为了计算标签ID小于15且帖子数量不超过20的数量，可以使用以下SQL语句：
SELECT ExcerptPostId, WikiPostId FROM tags WHERE TagName = 'sample';
SELECT u.Reputation, u.UpVotes FROM users u JOIN comments c ON u.Id = c.UserId WHERE c.Text = 'fine, you win :)';
SELECT c.Text FROM comments AS c JOIN posts AS p ON c.PostId = p.Id WHERE p.Title LIKE '%linear regression%';
SELECT c.Text AS HighestScoreComment FROM comments c JOIN posts p ON c.PostId = p.Id WHERE p.ViewCount BETWEEN 100 AND 150 GROUP BY c.PostId HAVING MAX(c.Score) IS NOT NULL;
SELECT u.CreationDate, DATEDIFF(YEAR, u.CreationDate, GETDATE()) AS Age FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Text LIKE '%http://%'
SELECT COUNT(DISTINCT posts.PostId) AS CountOfPosts FROM posts JOIN comments ON posts.PostId = comments.PostId WHERE comments.Score = 0 AND posts.ViewCount < 5;
SELECT COUNT(*) FROM comments WHERE PostId IN ( SELECT PostId FROM posts WHERE CommentCount = 1 ) AND Score = 0;
SELECT COUNT(DISTINCT u.Id) AS TotalUsersAge40 FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score = 0 AND u.Age = 40;
包裹，并且代码部分包含正确的SELECT语句。 </think> 根据题目要求，我们需要找到标题为 "Group differences on a five point Likert item" 的帖子 ID 以及该帖的所有评论。以下是实现这一查询的 SQL 语句：
SELECT u.UpVotes FROM users u JOIN comments c ON u.Id = c.UserId WHERE c.Text = 'R is also lazy evaluated.';
SELECT DISTINCT c.Text AS CommentText FROM comments c JOIN users u ON c.UserId = u.Id WHERE u.DisplayName = 'Harvey Motulsky';
SELECT DISTINCT u.DisplayName AS UserName FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 1 AND 5 AND u.DownVotes = 0;
SELECT ROUND( (COUNT(DISTINCT CASE WHEN u.UpVotes = 0 THEN c.UserId END)) * 100.0 / COUNT(DISTINCT CASE WHEN c.Score BETWEEN 5 AND 10 THEN c.UserId END), 2) AS Percentage FROM comments c JOIN users u ON c.UserId = u.Id WHERE c.Score BETWEEN 5 AND 10;
SELECT sp.power_name FROM superhero AS sh INNER JOIN hero_power AS hp ON sh.id = hp.hero_id INNER JOIN superpower AS sp ON hp.power_id = sp.id WHERE sh.superhero_name = '3-D Man';
SELECT COUNT(DISTINCT hp.hero_id) AS super_strength_count FROM hero_power hp JOIN ( SELECT id FROM superpower WHERE power_name = 'Super Strength' ) sp ON hp.power_id = sp.id;
SELECT COUNT(*) FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Super Strength' AND superhero.height_cm > 200;
SELECT superhero.full_name FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id GROUP BY superhero.id HAVING COUNT(DISTINCT hero_power.power_id) > 15;
SELECT COUNT(hero_id) FROM superhero JOIN colour ON eye_colour_id = colour.id WHERE colour = 'Blue';
SELECT colour FROM colour INNER JOIN superhero ON colour.id = superhero.skin_color_id WHERE superhero.superhero_name = 'Apocalypse';
SELECT COUNT(*) FROM superhero s JOIN colour c ON s.eye_colour_id = c.id JOIN hero_power hp ON s.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE c.colour = 'Blue' AND sp.power_name = 'Agility';
SELECT superhero.superhero_name FROM superhero LEFT JOIN colour AS eye_color ON superhero.eye_colour_id = eye_color.id LEFT JOIN colour AS hair_color ON superhero.hair_colour_id = hair_color.id WHERE eye_color.colour = 'Blue' AND hair_color.colour = 'Bald' ORDER BY superhero.superhero_name;
SELECT COUNT(*) AS marвел_comics_superheroes_count FROM superhero WHERE publisher_id = ( SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics' );
SELECT superhero.superhero_name AS name, superhero.height_cm AS height_cm, RANK() OVER (ORDER BY superhero.height_cm DESC) AS rank FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' ORDER BY superhero.height_cm DESC;
SELECT p.publisher_name FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.superhero_name = 'Sauron';
SELECT colour.name AS eye_color, COUNT(DISTINCT superhero.id) AS count, RANK() OVER (ORDER BY COUNT(DISTINCT superhero.id) DESC) AS rank FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics' GROUP BY colour.name ORDER BY count DESC;
SELECT AVG(height_cm) AS "Average Height (cm)" FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Marvel Comics';
SELECT superhero.superhero_name FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE publisher.publisher_name = 'Marvel Comics' AND superpower.power_name = 'Super Strength';
SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'DC Comics';
SELECT publisher_name FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.id = ( SELECT ha.hero_id FROM hero_attribute ha JOIN attribute a ON ha.attribute_id = a.id WHERE a.attribute_name = 'Speed' ORDER BY ha.attribute_value ASC LIMIT 1 );
SELECT COUNT(*) FROM superhero WHERE eye_colour_id = ( SELECT id FROM colour WHERE colour = 'Gold' ) AND publisher_id = ( SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics' );
SELECT publisher.publisher_name FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.superhero_name = 'Blue Beetle II';
SELECT COUNT(*) FROM superhero s JOIN colour c ON s.hair_colour_id = c.id WHERE c.colour = 'Blond';
SELECT superhero_name, attribute_value FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute_name = 'Intelligence' ORDER BY attribute_value ASC LIMIT 1;
SELECT r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.superhero_name = 'Copycat';
SELECT superhero_name FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute_name = 'Durability' AND attribute_value < 50;
SELECT superhero.superhero_name FROM superhero INNER JOIN hero_power ON superhero.id = hero_power.hero_id INNER JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Death Touch';
SELECT COUNT(DISTINCT h.id) AS female_strong_heroes_count FROM superhero h JOIN gender g ON h.gender_id = g.id JOIN hero_attribute ha ON h.id = ha.hero_id JOIN attribute a ON ha.attribute_id = a.id WHERE g.gender = 'Female' AND a.attribute_name = 'Strength' AND ha.attribute_value = 100;
SELECT s.superhero_name AS HeroName FROM superhero s JOIN ( SELECT hp.hero_id, COUNT(hp.power_id) AS PowerCount FROM hero_power hp GROUP BY hp.hero_id ) AS power_counts ON s.id = power_counts.hero_id ORDER BY PowerCount DESC LIMIT 1;
SELECT COUNT(*) AS vampire_count FROM superhero JOIN race ON superhero.race_id = race.id WHERE race = 'Vampire';
SELECT (COUNT(CASE WHEN a.alignment = 'Bad' THEN s.id END) / COUNT(s.id)) * 100 AS percentage, COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' AND a.alignment = 'Bad' THEN s.id END) AS marvel_count FROM superhero s JOIN alignment a ON s.alignment_id = a.id LEFT JOIN publisher p ON s.publisher_id = p.id WHERE a.alignment = 'Bad';
SELECT (COUNT(*) FILTER (WHERE publisher_name = 'Marvel Comics')) - (COUNT(*) FILTER (WHERE publisher_name = 'DC Comics')) AS difference FROM superhero s JOIN publisher p ON s.publisher_id = p.id;
SELECT id FROM publisher WHERE publisher_name = 'Star Trek';
SELECT AVG(attribute_value) FROM hero_attribute;
SELECT COUNT(*) FROM superhero WHERE full_name IS NULL;
SELECT colour.colour FROM superhero LEFT JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.id = 75;
SELECT sp.power_name FROM superhero AS s JOIN hero_power AS hp ON s.id = hp.hero_id JOIN superpower AS sp ON hp.power_id = sp.id WHERE s.superhero_name = 'Deathlok';
SELECT AVG(weight_kg) AS average_female_weight FROM superhero WHERE gender_id IN (SELECT id FROM gender WHERE gender = 'Female') LIMIT 1;
SELECT DISTINCT sp.power_name FROM superpower AS sp JOIN hero_power AS hp ON sp.id = hp.power_id JOIN superhero AS sh ON hp.hero_id = sh.id JOIN gender AS g ON sh.gender_id = g.id WHERE g.gender = 'Male' ORDER BY sp.power_name LIMIT 5;
SELECT superhero.superhero_name FROM superhero JOIN race ON superhero.race_id = race.id WHERE race.race = 'Alien';
SELECT superhero.superhero_name FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.height_cm BETWEEN 170 AND 190 AND (superhero.eye_colour_id IS NULL OR colour.colour = 'No Colour');
SELECT power_name FROM superpower JOIN hero_power ON superpower.id = hero_power.power_id WHERE hero_power.hero_id = 56;
SELECT superhero.full_name FROM superhero INNER JOIN race ON superhero.race_id = race.id WHERE race.race = 'Demi-God';
SELECT COUNT(*) FROM superhero WHERE alignment_id = (SELECT id FROM alignment WHERE alignment = 'Bad');
SELECT race.name AS race_of_superhero FROM superhero LEFT JOIN race ON superhero.race_id = race.id WHERE superhero.weight_kg = 169;
SELECT colour.colour AS hairColour FROM superhero JOIN colour ON superhero.hair_colour_id = colour.id JOIN race ON superhero.race_id = race.id WHERE superhero.height_cm = 185 AND race.race = 'human';
SELECT c.colour AS eye_colour FROM colour c JOIN superhero s ON c.id = s.eye_colour_id WHERE s.weight_kg = (SELECT MAX(weight_kg) FROM superhero);
WITH hero_count AS ( SELECT COUNT(*) as total, SUM(CASE WHEN publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics') THEN 1 ELSE 0 END) as marvel_count FROM superhero WHERE height_cm BETWEEN 150 AND 180 ) SELECT ROUND((marvel_count * 100.0 / total), 2) AS percentage FROM hero_count;
SELECT s.superhero_name FROM superhero s INNER JOIN gender g ON s.gender_id = g.id WHERE g.text = 'Male' AND s.weight_kg > (SELECT AVG(s2.weight_kg) * 0.79 FROM superhero s2)
WITH power_counts AS ( SELECT sp.power_name, COUNT(*) as count FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id GROUP BY sp.power_name ) SELECT power_name, count FROM power_counts WHERE count = (SELECT MAX(count) FROM power_counts);
SELECT ha.attribute_value FROM superhero AS s JOIN hero_attribute AS ha ON s.id = ha.hero_id WHERE s.superhero_name = 'Abomination';
SELECT power_name FROM superpower INNER JOIN hero_power ON superpower.id = hero_power.power_id WHERE hero_power.hero_id = 1;
SELECT COUNT(DISTINCT hp.hero_id) AS stealth_hero_count FROM hero_power hp JOIN superpower sp ON hp.power_id = sp.id WHERE sp.power_name = 'stealth';
SELECT superhero.full_name AS hero_full_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute_name = 'strength' AND attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute_name = 'strength' );
SELECT (COUNT(superhero.id) FILTER WHERE skin_colour_id IS NULL OR skin_colour_id = 1) / COUNT(*) AS average FROM superhero;
SELECT COUNT(superhero.id) AS num_superheroes FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher.publisher_name = 'Dark Horse Comics';
SELECT superhero.superhero_name, MAX(hero_attribute.attribute_value) AS max_durability FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE publisher.publisher_name = 'Dark Horse Comics' AND attribute.attribute_name = 'durability' GROUP BY superhero.superhero_name;
SELECT colour.colour FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.full_name = 'Abraham Sapien';
SELECT superhero.superhero_name FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Flight';
SELECT e.colour AS eye_color, h.colour AS hair_color, s.colour AS skin_color FROM superhero INNER JOIN gender g ON superhero.gender_id = g.id INNER JOIN publisher p ON superhero.publisher_id = p.id INNER JOIN colour e ON superhero.eye_colour_id = e.id INNER JOIN colour h ON superhero.hair_colour_id = h.id INNER JOIN colour s ON superhero.skin_colour_id = s.id WHERE g.gender = 'Female' AND p.publisher_name = 'Dark Horse Comics';
SELECT superhero.superhero_name, publisher.publisher_name FROM superhero INNER JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.eye_colour_id = superhero.hair_colour_id AND superhero.eye_colour_id = superhero.skin_colour_id;
SELECT race.race AS group_name FROM superhero JOIN race ON superhero.race_id = race.id WHERE superhero.superhero_name = 'A-Bomb';
WITH female_superheroes AS ( SELECT s.id, g.gender_name, c.skin_colour FROM superhero s JOIN gender g ON s.gender_id = g.id LEFT JOIN colour c ON s.skin_colour_id = c.id WHERE g.gender_name = 'Female' ) SELECT ROUND( (COUNT(*) FILTER (WHERE skin_colour = 'Blue') / COUNT(*)) * 100, 0 ) AS blue_female_percentage FROM female_superheroes;
SELECT superhero.superhero_name, race.race FROM superhero JOIN race ON superhero.race_id = race.id WHERE superhero.full_name = 'Charles Chandler';
SELECT superhero.superhero_name, gender.gender FROM superhero INNER JOIN gender ON superhero.gender_id = gender.id WHERE superhero.superhero_name = 'Agent 13';
SELECT superhero.superhero_name FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Adaptation';
SELECT COUNT(DISTINCT hp.power_id) AS power_count FROM superhero s JOIN hero_power hp ON s.id = hp.hero_id WHERE s.superhero_name = 'Amazo';
SELECT sp.power_name FROM superpower AS sp INNER JOIN hero_power AS hp ON sp.id = hp.power_id INNER JOIN superhero AS sh ON hp.hero_id = sh.id WHERE sh.full_name = 'Hunter Zolomon';
SELECT superhero.height_cm FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Amber';
SELECT DISTINCT superhero.superhero_name FROM superhero JOIN colour AS eye_colour ON superhero.eye_colour_id = eye_colour.id JOIN colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id WHERE eye_colour.colour = 'Black' AND hair_colour.colour = 'Black';
SELECT c.colour AS eye_colour FROM superhero s JOIN colour cl ON s.skin_colour_id = cl.id -- Join to filter heroes with gold skin JOIN colour c ON s.eye_colour_id = c.id -- Join to get eye colours WHERE cl.colour = 'Gold';
SELECT superhero.full_name, race.race AS race_type FROM superhero LEFT JOIN race ON race.id = superhero.race_id WHERE race_type = 'Vampire';
SELECT superhero.superhero_name AS "Superhero Name" FROM superhero JOIN alignment ON superhero.alignment_id = alignment.id WHERE alignment.alignment = 'Neutral';
WITH strength_attribute AS ( SELECT id FROM attribute WHERE attribute_name = 'Strength' ), max_strength_value AS ( SELECT MAX(attribute_value) as max_val FROM hero_attribute WHERE attribute_id = (SELECT id FROM strength_attribute) ) SELECT COUNT(*) FROM hero_attribute WHERE attribute_id = (SELECT id FROM strength_attribute) AND attribute_value = (SELECT max_val FROM max_strength_value);
SELECT r.race, a.alignment FROM superhero s JOIN race r ON s.race_id = r.id JOIN alignment a ON s.alignment_id = a.id WHERE s.superhero_name = 'Cameron Hicks';
SELECT publisher_name, (SUM(CASE WHEN gender = 'Female' THEN 1 ELSE 0 END) / SUM(1)) * 100 AS female_percentage FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher_name = 'Marvel Comics' GROUP BY publisher_name;
SELECT AVG(weight_kg) FROM superhero JOIN race ON superhero.race_id = race.id WHERE race.text = 'Alien';
SELECT (SELECT weight_kg FROM superhero WHERE full_name = 'Emil Blonsky') - (SELECT weight_kg FROM superhero WHERE full_name = 'Charles Chandler');
SELECT AVG(height_cm) AS average_height FROM superhero;
SELECT superhero.superhero_name, superpower.power_name FROM superhero LEFT JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superhero.superhero_name = 'Abomination';
SELECT COUNT(*) AS "Count of Male God/Eternal Heroes" FROM superhero WHERE race_id = 21 AND gender_id = 1;
SELECT superhero.superhero_name AS fastest_hero FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id INNER JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE attribute.attribute_name = 'Speed' GROUP BY superhero.id ORDER BY MAX(hero_attribute.attribute_value) DESC LIMIT 1;
SELECT COUNT(*) FROM superhero WHERE alignment_id = 3;
SELECT a.attribute_name, ha.attribute_value FROM superhero AS s JOIN hero_attribute AS ha ON s.id = ha.hero_id JOIN attribute AS a ON ha.attribute_id = a.id WHERE s.superhero_name = '3-D Man';
SELECT superhero.superhero_name FROM superhero INNER JOIN colour AS eye_colour ON superhero.eye_colour_id = eye_colour.id INNER JOIN colour AS hair_colour ON superhero.hair_colour_id = hair_colour.id WHERE eye_colour.colour = 'Blue' AND hair_colour.colour = 'Brown' ORDER BY superhero.superhero_name;
SELECT p.publisher_name FROM publisher p JOIN superhero s ON s.publisher_id = p.id WHERE s.superhero_name IN ('Hawkman', 'Karate Kid', 'Speedy');
SELECT COUNT(*) FROM superhero WHERE publisher_id IS NULL;
SELECT (COUNT(*) FILTER (WHERE colour.text = 'Blue') / COUNT(superhero.superhero_name)) * 100 AS blue_eyes_percentage FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id;
SELECT DIVIDE( COUNT(*) FILTER (WHERE gender_id = 1), COUNT(*) FILTER (WHERE gender_id = 2) ) AS ratio FROM superhero;
SELECT superhero_name FROM superhero WHERE height_cm = (SELECT MAX(height_cm) FROM superhero)
SELECT id FROM superpower WHERE power_name = 'cryokinesis';
SELECT superhero_name FROM superhero WHERE id = 294;
SELECT full_name FROM superhero WHERE weight_kg = 0 OR weight_kg IS NULL;
SELECT colour.colour FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.full_name = 'Karen Beecher-Duncan';
SELECT sp.power_name FROM superpower AS sp JOIN hero_power AS hp ON sp.id = hp.power_id JOIN superhero AS sh ON hp.hero_id = sh.id WHERE sh.full_name = 'Helen Parr';
SELECT r.race FROM superhero s JOIN race r ON s.race_id = r.id WHERE s.weight_kg = 108 AND s.height_cm = 188;
SELECT publisher.publisher_name FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE superhero.id = 38;
SELECT race FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id WHERE attribute_value = ( SELECT MAX(attribute_value) FROM hero_attribute )
SELECT s.superhero_name AS "Superhero Name", a.alignment AS "Alignment", sp.power_name AS "Superpower" FROM superhero s LEFT JOIN alignment a ON s.alignment_id = a.id LEFT JOIN hero_power hp ON s.id = hp.hero_id LEFT JOIN superpower sp ON hp.power_id = sp.id WHERE s.superhero_name = 'Atom IV';
SELECT superhero.full_name FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'Blue' LIMIT 5;
SELECT AVG(hero_attribute.attribute_value) AS average_attribute_value FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id WHERE superhero.alignment_id = 3;
SELECT DISTINCT colour.colour FROM colour INNER JOIN superhero ON colour.id = superhero.skin_colour_id INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id WHERE hero_attribute.attribute_value = 100;
SELECT COUNT(*) AS good_female_superheroes FROM superhero WHERE gender_id = 2 AND alignment_id = 1;
SELECT superhero_name FROM superhero INNER JOIN hero_attribute ON superhero.id = hero_attribute.hero_id WHERE attribute_value BETWEEN 75 AND 80;
SELECT race.race FROM superhero JOIN race ON superhero.race_id = race.id JOIN gender ON superhero.gender_id = gender.id JOIN colour hairColour ON superhero.hair_colour_id = hairColour.id WHERE hairColour.colour = 'blue' AND gender.gender = 'male';
SELECT (SUM(CASE WHEN gender_id = 2 THEN 1 ELSE 0 END) / COUNT(*)) * 100 AS female_percentage FROM superhero WHERE alignment_id = 2;
SELECT (SUM(CASE WHEN T1.eye_colour_id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T1.eye_colour_id = 1 THEN 1 ELSE 0 END)) AS difference FROM superhero T1 WHERE T1.weight_kg IN (0, NULL);
SELECT ha.attribute_value FROM hero_attribute ha JOIN superhero s ON ha.hero_id = s.id JOIN attribute a ON ha.attribute_id = a.id WHERE s.superhero_name = 'Hulk' AND a.attribute_name = 'Strength';
SELECT power_name FROM superpower INNER JOIN hero_power ON superpower.id = hero_power.power_id INNER JOIN superhero ON hero_power.hero_id = superhero.id WHERE superhero_name = 'Ajax';
SELECT COUNT(*) FROM superhero JOIN colour ON superhero.skin_colour_id = colour.id JOIN alignment ON superhero.alignment_id = alignment.id WHERE colour.colour = 'Green' AND alignment.alignment = 'Bad';
SELECT COUNT(*) FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE gender_id = (SELECT id FROM gender WHERE gender = 'Female') AND publisher_name = 'Marvel Comics';
SELECT DISTINCT superhero.superhero_name FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Wind Control' ORDER BY superhero.superhero_name;
SELECT g.gender FROM gender g JOIN superhero s ON g.id = s.gender_id JOIN hero_power hp ON s.id = hp.hero_id WHERE hp.power_id IN ( SELECT id FROM superpower WHERE power_name = 'Phoenix Force' );
SELECT superhero_name, MAX(weight_kg) AS heaviest_weight FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id WHERE publisher_name = 'DC Comics' GROUP BY superhero_name ORDER BY heaviest_weight DESC LIMIT 1;
SELECT AVG(height_cm) AS average_height FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id JOIN race ON superhero.race_id = race.id WHERE publisher.publisher_name = 'Dark Horse Comics' AND race.race != 'Human';
SELECT COUNT(*) AS fastest_superheroes_count FROM hero_attribute ha JOIN attribute a ON ha.attribute_id = a.id WHERE a.attribute_name = 'Speed' AND ha.attribute_value = 100;
SELECT COUNT(CASE WHEN publisher_name = 'DC Comics' THEN 1 END) - COUNT(CASE WHEN publisher_name = 'Marvel Comics' THEN 1 END) AS difference FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name IN ('DC Comics', 'Marvel Comics');
SELECT attribute.attribute_name, hero_attribute.attribute_value FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE superhero.superhero_name = 'Black Panther' ORDER BY hero_attribute.attribute_value ASC LIMIT 1;
SELECT colour.colour FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.superhero_name = 'Abomination';
SELECT superhero_name AS "Superhero Name", MAX(height_cm) AS "Tallest Height" FROM superhero WHERE height_cm IS NOT NULL ORDER BY height_cm DESC LIMIT 1;
SELECT superhero_name FROM superhero WHERE full_name = 'Charles Chandler';
SELECT (COUNT(*) FILTER (WHERE gender.gender = 'Female') / COUNT(superhero.publisher_id)) * 100 AS female_percentage FROM superhero JOIN publisher ON superhero.publisher_id = publisher.id JOIN gender ON superhero.gender_id = gender.id WHERE publisher.publisher_name = 'George Lucas';
WITH total_marvel AS ( SELECT COUNT(*) as total FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'Marvel Comics' ), good_count AS ( SELECT COUNT(*) as count FROM superhero s JOIN alignment a ON s.alignment_id = a.id JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'Marvel Comics' AND a.alignment = 'Good' ) SELECT ROUND((good_count.count / total_marvel.total) * 100, 2) as good_percentage FROM total_marvel, good_count;
SELECT COUNT(*) FROM superhero WHERE full_name LIKE 'John%';
SELECT h.id FROM superhero h JOIN hero_attribute ha ON h.id = ha.hero_id WHERE ha.attribute_value = ( SELECT MIN(attribute_value) FROM hero_attribute );
SELECT full_name FROM superhero WHERE superhero_name = 'Alien' LIMIT 1;
SELECT superhero.full_name FROM superhero JOIN colour ON superhero.eye_colour_id = colour.id WHERE colour.colour = 'brown' AND superhero.weight_kg < 100;
SELECT attribute.attribute_name, hero_attribute.attribute_value FROM superhero JOIN hero_attribute ON superhero.id = hero_attribute.hero_id JOIN attribute ON hero_attribute.attribute_id = attribute.id WHERE superhero.superhero_name = 'Aquababy';
SELECT superhero.weight_kg, race.race FROM superhero JOIN race ON superhero.race_id = race.id WHERE superhero.id = 40;
SELECT AVG(height_cm) AS average_height FROM superhero JOIN alignment ON superhero.alignment_id = alignment.id WHERE alignment.alignment = 'neutral';
SELECT superhero.id FROM superhero JOIN hero_power ON superhero.id = hero_power.hero_id JOIN superpower ON hero_power.power_id = superpower.id WHERE superpower.power_name = 'Intelligence';
SELECT colour.colour FROM superhero INNER JOIN colour ON superhero.eye_colour_id = colour.id WHERE superhero.superhero_name = 'Blackwulf';
SELECT DISTINCT hp.power_name AS power_of_superhero FROM superhero sh JOIN hero_power hp ON sh.id = hp.hero_id WHERE sh.height_cm > ( SELECT AVG(sh.height_cm) * 0.8 FROM superhero sh );
SELECT q.driverRef, d.forename || ' ' || d.surname AS driverName FROM ( SELECT driverId, driverRef, constructorId, raceId, q1, RANK() OVER (ORDER BY q1 DESC) AS q1_rank FROM qualifying WHERE raceId = 20 ) q JOIN drivers d ON q.driverId = d.driverId WHERE q.q1_rank <= 5;
SELECT drivers.surname FROM qualifying JOIN drivers ON qualifying.driverId = drivers.driverId WHERE qualifying.raceId = 19 AND qualifying.q2 = ( SELECT MIN(q2) FROM qualifying WHERE raceId = 19 );
SELECT DISTINCT races.year AS held_year FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.location = 'Shanghai';
SELECT races.url FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Circuit de Barcelona-Catalunya';
SELECT races.name AS race_name FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country = 'Germany';
SELECT c.location FROM circuits c JOIN races r ON c.circuitId = r.circuitId JOIN constructorResults cr ON r.raceId = cr.raceId WHERE cr.constructorId = ( SELECT constructorId FROM constructors WHERE name = 'Renault' );
SELECT COUNT(*) FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.year = 2010 AND circuits.country NOT IN ('Asia', 'Europe');
SELECT races.name AS race_name FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country = 'Spain';
SELECT circuits.lat, circuits.lng FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.name = 'Australian Grand Prix';
SELECT races.url FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Sepang International Circuit';
SELECT races.time FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Sepang International Circuit';
SELECT lat, lng FROM races WHERE name = 'Abu Dhabi Grand Prix';
SELECT constructors.nationality FROM races JOIN results ON races.raceId = results.raceId JOIN constructors ON results.constructorId = constructors.constructorId WHERE races.raceId = 24 AND results.points = 1;
SELECT q.q1 FROM qualifying AS q JOIN drivers AS d ON q.driverId = d.driverId WHERE q.raceId = 354 AND d.forename = 'Bruno' AND d.surname = 'Senna';
SELECT drivers.nationality FROM qualifying JOIN drivers ON qualifying.driverId = drivers.driverId WHERE qualifying.raceId = 355 AND qualifying.q2 = '0:01:40';
SELECT number FROM qualifying WHERE raceId = 903 AND q3 LIKE '0:01:54%'
SELECT COUNT(*) AS driversDidNotFinish FROM races JOIN results ON races.raceId = results.raceId WHERE races.name = 'Bahrain Grand Prix' AND races.year = 2007 AND results.time IS NULL;
SELECT r.year AS season_year, COUNT(r.raceId) AS total_races_in_season, -- Driver with most wins in the season (SELECT driverId FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = r.year) GROUP BY driverId ORDER BY SUM(CASE WHEN position = 1 THEN 1 ELSE 0 END) DESC LIMIT 1) AS driver_with_most_wins, -- Constructor with most wins in the season (SELECT constructorId FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = r.year) GROUP BY constructorId ORDER BY SUM(CASE WHEN position = 1 THEN 1 ELSE 0 END) DESC LIMIT 1) AS constructor_with_most_wins, -- Total points scored by drivers in the season (SELECT SUM(points) FROM results WHERE raceId IN (SELECT raceId FROM races WHERE year = r.year)) AS total_points_scored, -- Average number of laps per race (SELECT AVG(laps) FROM races WHERE year = r.year) AS average_laps_per_race, -- Fastest lap holder in the season (SELECT driverId FROM lapTimes WHERE raceId IN (SELECT raceId FROM races WHERE year = r.year) GROUP BY raceId, driverId ORDER BY milliseconds ASC LIMIT 1) AS fastest_lap_holder FROM races r WHERE r.raceId = 901;
SELECT COUNT(DISTINCT driverId) AS numberOfDriversFinished FROM results INNER JOIN races ON results.raceId = races.raceId WHERE races.date = '2015-11-29' AND results.time IS NOT NULL;
SELECT d.dob AS oldest_dob FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN races ra ON ra.raceId = r.raceId WHERE ra.raceId = 592 AND r.time IS NOT NULL GROUP BY r.driverId ORDER BY d.dob ASC LIMIT 1;
SELECT drivers.name AS player, drivers.url AS introduction_website FROM lapTimes JOIN races ON lapTimes.raceId = races.raceId JOIN drivers ON lapTimes.driverId = drivers.driverId WHERE races.raceId = 161 AND lapTimes.time LIKE '0:01:27%';
SELECT d.nationality AS driverNationality FROM drivers d WHERE EXISTS ( SELECT 1 FROM results r WHERE r.raceId = 933 AND r.statusId != 0 -- Ensure status is valid AND r.driverId = d.driverId AND r.fastestLapSpeed = ( SELECT MAX(r2.fastestLapSpeed) FROM results r2 WHERE r2.raceId = 933 AND r2.statusId != 0 -- Ensure status is valid ) );
SELECT races.circuitId, circuits.lat, circuits.lng FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.name = 'Malaysian Grand Prix';
SELECT c.url AS constructor_website, c.constructorRef, c.name FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId WHERE cr.raceId = 9 AND cr.points = ( SELECT MAX(points) FROM constructorResults WHERE raceId = 9 ) LIMIT 1;
SELECT q.q1 AS Q1, d.forename || ' ' || d.surname AS DriverName FROM qualifying q JOIN drivers d ON q.driverId = d.driverId WHERE q.raceId = 345 AND d.forename = 'Lucas' AND d.surname = 'di Grassi';
SELECT d.nationality FROM qualifying q INNER JOIN races r ON q.raceId = r.raceId INNER JOIN drivers d ON q.driverId = d.driverId WHERE r.raceId = 347 AND q.q2 = '0:01:15';
SELECT drivers.code FROM drivers INNER JOIN qualifying ON drivers.driverId = qualifying.driverId INNER JOIN races ON qualifying.raceId = races.raceId WHERE races.raceId = 45 AND qualifying.q3 LIKE '0:01:33';
SELECT time FROM results JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.raceId = 743 AND drivers.forename = 'Bruce' AND drivers.surname = 'McLaren';
SELECT drivers.name AS driver_name FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.year = 2006 AND races.name = 'San Marino Grand Prix' AND results.position = 2;
SELECT s.url AS season_page_url FROM seasons s WHERE s.year = ( SELECT r.year FROM races r WHERE r.raceId = 901 );
SELECT COUNT(DISTINCT driverId) AS driversDidNotFinish FROM results JOIN races ON races.raceId = results.raceId JOIN status ON status.statusId = results.statusId WHERE races.date = '2015-11-29' AND status.status = 'DNF';
SELECT d.driverId, d.name, d.dob FROM drivers AS d JOIN results AS r ON d.driverId = r.driverId WHERE r.raceId = 872 AND r.time IS NOT NULL ORDER BY d.dob DESC LIMIT 1;
WITH best_laps AS ( SELECT driverId, MIN(time) as min_time FROM lapTimes WHERE raceId = 348 GROUP BY driverId ) SELECT drivers.forename || ' ' || drivers.surname as full_name FROM best_laps JOIN drivers ON best_laps.driverId = drivers.driverId ORDER BY min_time ASC LIMIT 1;
SELECT drivers.nationality FROM results JOIN drivers ON results.driverId = drivers.driverId WHERE results.fastestLapSpeed = ( SELECT MAX(results.fastestLapSpeed) FROM results WHERE results.fastestLapSpeed IS NOT NULL );
WITH cte AS ( SELECT r.raceId, r.fastestLapSpeed, d.driverId FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE d.forename = 'Paul' AND d.surname = 'di Resta' ) SELECT (race853.fastestLapSpeed / race854.fastestLapSpeed - 1) * 100 AS percentage_faster FROM cte race853 JOIN cte race854 ON race853.driverId = race854.driverId WHERE race853.raceId = 853 AND race854.raceId = 854;
SELECT (COUNT(DISTINCT CASE WHEN time IS NOT NULL THEN driverId END) * 100.0 / COUNT(DISTINCT driverId)) AS completion_rate FROM results JOIN races ON races.raceId = results.raceId WHERE races.date = '1983-07-16';
SELECT MIN(year) AS first_singapore_year FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country = 'Singapore';
SELECT COUNT(*) AS NumberOfRaces FROM races WHERE year = 2005 UNION ALL SELECT name FROM races WHERE year = 2005 ORDER BY name DESC;
-- Get the earliest date SELECT date AS earliest_date FROM races ORDER BY date ASC LIMIT 1; -- Extract the earliest year and month from the earliest date SELECT strftime('%Y', earliest_date) AS earliest_year, strftime('%m', earliest_date) AS earliest_month FROM (SELECT date AS earliest_date FROM races ORDER BY date ASC LIMIT 1); -- List all races that occurred in the earliest recorded year and month SELECT name FROM races WHERE date = ( SELECT date FROM races ORDER BY date ASC LIMIT 1 );
SELECT name, date FROM races WHERE year = 1999 AND round = (SELECT MAX(round) FROM races WHERE year = 1999);
SELECT year AS most_races_year FROM ( SELECT year, MAX(round) as max_round FROM races GROUP BY year ORDER BY max_round DESC ) WHERE rowid = 1;
SELECT name FROM races WHERE year = 2017 AND circuitId NOT IN ( SELECT circuitId FROM races WHERE year = 2000 );
SELECT c.country, c.name AS circuitName, c.location FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE c.country LIKE '%Europe%' ORDER BY r.year ASC LIMIT 1;
SELECT MAX(year) AS last_british_gp_year FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Brands Hatch';
SELECT COUNT(DISTINCT year) AS seasons_count FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.location = 'Silverstone' AND circuits.country = 'United Kingdom';
SELECT r.year AS year, race.name AS race_name, driver.forename || ' ' || driver.surname AS driver_name, result.position AS position, constructor.name AS constructor_name FROM races race JOIN results result ON race.raceId = result.raceId JOIN drivers driver ON result.driverId = driver.driverId JOIN constructors constructor ON result.constructorId = constructor.constructorId WHERE race.year = 2010 AND race.name = 'Singapore Grand Prix' ORDER BY result.position;
SELECT drivers.forename AS forename, drivers.surname AS surname, SUM(driverStandings.points) AS total_points FROM driverStandings JOIN drivers ON driverStandings.driverId = drivers.driverId GROUP BY driverStandings.driverId ORDER BY total_points DESC LIMIT 1;
SELECT ds.points, d.forename || ' ' || d.surname AS driver_name FROM driverStandings ds JOIN drivers d ON ds.driverId = d.driverId WHERE ds.raceId IN ( SELECT r.raceId FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2017 AND c.country = 'China' ) ORDER BY ds.points DESC, ds.position ASC LIMIT 3;
WITH BestLap AS ( SELECT lt.raceId, lt.driverId, lt.milliseconds, ROW_NUMBER() OVER (ORDER BY lt.milliseconds ASC) AS rn FROM lapTimes lt JOIN drivers d ON lt.driverId = d.driverId JOIN races r ON lt.raceId = r.raceId ) SELECT forename, surname, name AS raceName, milliseconds FROM BestLap WHERE rn = 1;
SELECT AVG(lapTimes.milliseconds) AS average_lap_time FROM lapTimes JOIN races ON lapTimes.raceId = races.raceId JOIN drivers ON lapTimes.driverId = drivers.driverId WHERE races.name = 'Malaysian Grand Prix' AND races.year = 2009 AND drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton';
WITH hamilton_races AS ( SELECT r.resultId, r.position, r.year FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE d.surname = 'Hamilton' AND r.year >= 2010 ) SELECT ROUND( (COUNT(CASE WHEN position > 1 THEN 1 END) / COUNT(*)) * 100, 2 ) AS percentage FROM hamilton_races;
SELECT drivers.forename AS first_name, drivers.surname AS last_name, drivers.nationality, MAX(driverStandings.points) AS max_points FROM drivers JOIN driverStandings ON drivers.driverId = driverStandings.driverId GROUP BY drivers.driverId ORDER BY COUNT(driverStandings.wins) DESC, max_points DESC;
SELECT MIN(YEAR(CURRENT_TIMESTAMP) - YEAR(dob)) AS youngest_age, forename || ' ' || surname AS name, dob FROM drivers WHERE nationality = 'Japanese' GROUP BY dob;
SELECT c.name, c.location FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE strftime('%Y', r.date) BETWEEN 1990 AND 2000 GROUP BY c.circuitId HAVING COUNT(*) >= 4;
SELECT c.name AS circuit_name, c.location, r.name AS race_name FROM circuits c JOIN races r ON c.circuitId = r.circuitId WHERE r.year = 2006 AND LOWER(c.country) = 'usa';
SELECT races.name AS raceName, circuits.name AS circuitName, circuits.location FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE strftime('%Y-%m', races.date) = '2005-09';
SELECT r.raceId, r.year, r.name, r.date FROM races AS r JOIN results AS res ON r.raceId = res.raceId JOIN drivers AS d ON res.driverId = d.driverId WHERE d.forename = 'Alex' AND d.surname = 'Yoong' AND res.grid < 20;
SELECT COUNT(*) AS winCount FROM results r INNER JOIN races ra ON r.raceId = ra.raceId INNER JOIN circuits c ON ra.circuitId = c.circuitId INNER JOIN drivers d ON r.driverId = d.driverId WHERE d.forename = 'Michael' AND d.surname = 'Schumacher' AND c.name = 'Sepang International Circuit' AND r.points = ( SELECT MAX(points) FROM results WHERE raceId = r.raceId ) AND r.position = 1;
SELECT races.name AS race, races.year FROM results JOIN drivers ON results.driverId = drivers.driverId JOIN races ON results.raceId = races.raceId WHERE drivers.forename = 'Michael' AND drivers.surname = 'Schumacher' AND results.milliseconds != 0 AND results.resultId = ( SELECT MIN(resultId) FROM results WHERE raceId = results.raceId AND driverId = results.driverId AND milliseconds != 0 ) GROUP BY races.year, races.name;
SELECT AVG(points) AS average_points FROM results JOIN races ON results.raceId = races.raceId WHERE races.year = 2000 AND results.driverId = ( SELECT driverId FROM drivers WHERE forename = 'Eddie' AND surname = 'Irvine' );
SELECT races.year AS first_race_year, results.points AS points FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' ORDER BY races.year ASC LIMIT 1;
SELECT races.name AS raceName, races.country FROM races WHERE races.year = 2017 ORDER BY races.date;
SELECT races.name AS race_name, races.year AS race_year, circuits.location AS circuit_location FROM results JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId WHERE results.laps = ( SELECT MAX(laps) FROM results ) LIMIT 1;
SELECT (COUNT(*) * 100.0 / SUM(CASE WHEN name = 'European Grand Prix' THEN 1 ELSE 0 END)) OVER () AS germany_percentage, COUNT(*) as total_european_races, SUM(CASE WHEN country = 'Germany' AND name = 'European Grand Prix' THEN 1 ELSE 0 END) as german_races FROM races WHERE name = 'European Grand Prix';
SELECT lat, lng FROM circuits WHERE name = 'Silverstone Circuit';
SELECT name, lat FROM circuits WHERE name IN ('Silverstone Circuit', 'Hockenheimring', 'Hungaroring') ORDER BY lat DESC;
SELECT circuitRef FROM circuits WHERE name = 'Marina Bay Street Circuit';
SELECT country FROM circuits AS c1 GROUP BY country HAVING MAX(alt) = (SELECT MAX(alt) FROM circuits);
SELECT COUNT(*) FROM drivers WHERE code IS NULL;
SELECT nationality FROM drivers WHERE dob = (SELECT MIN(dob) FROM drivers);
SELECT surname FROM drivers WHERE nationality = 'italian';
SELECT url FROM drivers WHERE driverId = [Anthony Davidson's driverId];
SELECT driverRef FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton';
SELECT races.year, races.name AS raceName, circuits.name AS circuitName FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.year = 2009 AND races.name = 'Spanish Grand Prix';
SELECT DISTINCT races.year FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Silverstone Circuit' ORDER BY races.year;
SELECT races.year AS year, races.name AS race_name, races.date AS race_date, circuits.url AS circuit_url FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Silverstone Circuit' ORDER BY races.year;
SELECT races.time FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.year = 2010 AND circuits.name = 'Abu Dhabi';
SELECT COUNT(races.raceId) FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.country = 'Italy';
SELECT date FROM races JOIN circuits ON races.circuitId = circuits.circuitId WHERE circuits.name = 'Barcelona-Catalunya';
SELECT circuits.url AS circuit_url FROM races INNER JOIN circuits ON races.circuitId = circuits.circuitId WHERE races.year = 2009 AND races.name LIKE '%Spanish Grand Prix%';
SELECT MIN(fastestLapTime) AS fastest_lap_time FROM results JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.name = 'Lewis Hamilton' AND results.fastestLapTime IS NOT NULL;
SELECT drivers.forename, drivers.surname FROM results JOIN drivers ON results.driverId = drivers.driverId WHERE results.fastestLapSpeed IS NOT NULL AND results.fastestLapSpeed = ( SELECT MAX(fastestLapSpeed) FROM results WHERE fastestLapSpeed IS NOT NULL ) LIMIT 1;
SELECT r.driverId, d.driverRef FROM races AS r JOIN results AS res ON r.raceId = res.raceId JOIN drivers AS d ON res.driverId = d.driverId WHERE r.name = 'Canadian Grand Prix' AND r.year = 2007 AND res.position = 1;
SELECT races.raceId, races.year AS race_year, races.name AS race_name, races.date AS race_date FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.name = 'Lewis Hamilton';
SELECT r.year AS year, r.round AS round, r.raceId AS race_id FROM races r JOIN results res ON r.raceId = res.raceId JOIN drivers d ON res.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' AND res.rank = ( SELECT MIN(res2.rank) FROM results res2 WHERE res2.driverId = d.driverId ) LIMIT 1;
SELECT MAX(COALESCE(results.fastestLapSpeed, 0)) AS fastest_lap_speed FROM results WHERE raceId IN ( SELECT races.raceId FROM races WHERE races.year = 2009 AND races.name = 'Spanish Grand Prix' ) GROUP BY results.raceId;
SELECT DISTINCT races.year AS race_year FROM drivers JOIN results ON drivers.driverId = results.driverId JOIN races ON results.raceId = races.raceId WHERE drivers.driverRef = 'lewis-hamilton';
SELECT results.positionOrder FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.name = 'Chinese Grand Prix' AND races.year = 2008 AND drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton';
SELECT drivers.forename, drivers.surname FROM results JOIN races ON results.raceId = races.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.year = 1989 AND results.grid = 4;
SELECT COUNT(driverId) AS finishersCount FROM results JOIN races ON results.raceId = races.raceId WHERE races.name = '2008 Australian Grand Prix' AND results.time IS NOT NULL;
SELECT lt.raceId, lt.driverId, lt.lap, lt.time, lt.milliseconds FROM lapTimes AS lt WHERE raceId = ( SELECT r.raceId FROM races AS r WHERE r.year = 2008 AND r.name = 'Australian Grand Prix' ) AND driverId = ( SELECT d.driverId FROM drivers AS d WHERE d.name = 'Lewis Hamilton' ) ORDER BY lt.milliseconds ASC LIMIT 1;
SELECT results.time FROM races JOIN results ON races.raceId = results.raceId WHERE races.name = 'Chinese Grand Prix' AND races.year = 2008 AND results.position = 2;
SELECT drivers.forename || ' ' || drivers.surname AS champion_name, results.time AS finish_time, drivers.url AS more_info_url FROM races JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.year = 2008 AND races.name = 'Australian Grand Prix' AND results.position = 1;
SELECT COUNT(DISTINCT driverId) AS british_drivers_count FROM races AS R JOIN results AS Res ON R.raceId = Res.raceId JOIN drivers AS D ON Res.driverId = D.driverId WHERE R.name = 'Australian Grand Prix' AND R.year = 2008 AND D.nationality = 'British';
SELECT COUNT(DISTINCT r.driverId) AS participated_drivers_count FROM races ra JOIN results r ON ra.raceId = r.raceId WHERE ra.year = 2008 AND ra.name LIKE '%Chinese Grand Prix%' AND r.time IS NOT NULL;
SELECT SUM(points) AS total_points FROM results WHERE driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) GROUP BY raceId;
SELECT ROUND(AVG( (substr(fastestLapTime, 0, 2) * 60 + substr(fastestLapTime, 3, 2) + substr(fastestLapTime, 6, 3)/1000) ), 2) AS average_fastest_lap_time FROM results JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND fastestLapTime IS NOT NULL;
SELECT (COUNT(*) FILTER (WHERE time IS NOT NULL) / COUNT(*)) AS completion_rate FROM lapTimes WHERE raceId = 'race_id';
SELECT (CAST(last_driver_time AS REAL) - CAST(champion_time AS REAL)) / CAST(last_driver_time AS REAL) * 100 AS percentage_faster, champion_time, last_driver_time FROM ( SELECT r.time as champion_time, r.resultId, r.driverId, r.position FROM races r WHERE r.year = 2008 AND r.name = 'Australian Grand Prix' ) AS champion, ( SELECT r.time as last_driver_time, r.resultId, r.driverId, r.position FROM results r WHERE r.raceId IN ( SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix' ) ORDER BY r.position DESC LIMIT 1 ) AS last_driver;
SELECT COUNT(*) FROM circuits WHERE country = 'Australia' AND location = 'Adelaide';
SELECT lat, lng FROM circuits WHERE country = 'USA';
SELECT COUNT(driverId) FROM drivers WHERE nationality = 'British' AND strftime('%Y', dob) > 1980;
SELECT MAX(points) AS max_points FROM constructorStandings INNER JOIN constructors ON constructorStandings.constructorId = constructors.constructorId WHERE constructors.nationality = 'British';
SELECT constructorId, SUM(points) AS total_points FROM constructorResults GROUP BY constructorId ORDER BY total_points DESC LIMIT 1;
SELECT c.name AS constructor_name FROM races r JOIN constructorResults cr ON r.raceId = cr.raceId JOIN constructors c ON cr.constructorId = c.constructorId WHERE r.raceId = 291 AND cr.points = 0;
SELECT COUNT(DISTINCT c.constructorId) AS japanese_constructors_with_zero_points FROM constructors c WHERE c.nationality = 'Japanese' AND EXISTS ( SELECT 1 FROM constructorResults cr WHERE cr.constructorId = c.constructorId AND cr.points = 0 GROUP BY cr.raceId, cr.constructorId HAVING COUNT(cr.raceId) >= 2 );
SELECT * FROM constructorStandings WHERE position = 1;
SELECT COUNT(DISTINCT r.raceId) AS total_laps FROM constructors c JOIN results r ON c.constructorId = r.constructorId JOIN lapTimes lt ON r.raceId = lt.raceId AND r.driverId = lt.driverId WHERE c.nationality = 'French' AND lt.lap > 50;
SELECT (COUNT(DISTINCT CASE WHEN r.time IS NOT NULL THEN r.driverId END) / COUNT(DISTINCT r.driverId)) * 100 AS completion_percentage FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE d.nationality = 'Japanese' AND r.year BETWEEN 2007 AND 2009;
SELECT r.year AS year, AVG(total_seconds) AS avg_time_in_seconds FROM ( SELECT results.raceId, results.driverId, results.constructorId, results.grid, results.position, results.points, results.laps, results.time, results.milliseconds, races.year, (CONVERT(INT, SUBSTRING(results.time, 0, 2))) * 3600 + (CONVERT(INT, SUBSTRING(results.time, 3, 2))) * 60 + (CONVERT(INT, SUBSTRING(results.time, 6, 2))) AS total_seconds FROM results JOIN races ON results.raceId = races.raceId ) AS subquery WHERE position = 1 AND milliseconds IS NOT NULL AND year < 1975 GROUP BY year;
SELECT drivers.forename, drivers.surname FROM drivers JOIN driverStandings ON drivers.driverId = driverStandings.driverId WHERE driverStandings.position = 2 AND drivers.dob > '1975-01-01';
SELECT COUNT(DISTINCT r.driverId) AS italian_drivers_not_finished FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE r.time IS NULL AND d.nationality = 'Italian';
SELECT drivers.forename, drivers.surname FROM lapTimes JOIN drivers ON lapTimes.driverId = drivers.driverId WHERE lapTimes.milliseconds = ( SELECT MIN(millis) FROM lapTimes ) LIMIT 1;
SELECT results.fastestLap AS fastest_lap_number FROM races JOIN results ON races.raceId = results.raceId WHERE races.year = 2009 AND results.position = 1;
SELECT AVG(fastestLapSpeed) AS average_fastest_lap_speed FROM results JOIN races ON results.raceId = races.raceId WHERE races.name = 'Spanish Grand Prix';
SELECT r.name AS raceName, r.year FROM races r JOIN ( SELECT resultId, raceId, driverId, constructorId, grid, position, positionText, positionOrder, points, laps, time, milliseconds, fastestLap, rank, fastestLapTime, fastestLapSpeed, statusId FROM results ) AS res ON r.raceId = res.raceId WHERE res.milliseconds IS NOT NULL AND res.milliseconds = ( SELECT MIN(res2.milliseconds) FROM results res2 WHERE res2.milliseconds IS NOT NULL ) ORDER BY res.milliseconds ASC;
SELECT (COUNT(DISTINCT r.driverId) FILTER (WHERE d.dob < '1985-01-01' AND r.laps > 50)) / (COUNT(DISTINCT r.driverId) FILTER (WHERE races.year BETWEEN 2000 AND 2005)) * 100 AS percentage FROM results r JOIN races ON r.raceId = races.raceId JOIN drivers d ON r.driverId = d.driverId WHERE races.year >= 2000 AND races.year <= 2005;
SELECT COUNT(DISTINCT d.driverId) AS french_drivers_with_fast_laps FROM drivers d LEFT JOIN lapTimes l ON d.driverId = l.driverId WHERE d.nationality = 'French' AND l.milliseconds < 120000;
SELECT * FROM drivers WHERE nationality = 'America';
SELECT raceId FROM races WHERE year = 2009;
SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = 18;
SELECT COUNT(*) AS netherlands_drivers FROM ( SELECT nationality FROM drivers ORDER BY dob DESC LIMIT 3 ) subquery WHERE nationality IN ('Netherlands', 'Dutch');
SELECT driverRef FROM drivers WHERE forename = 'Robert' AND surname = 'Kubica';
SELECT COUNT(*) FROM drivers WHERE nationality = 'British' AND YEAR(dob) = 1980;
SELECT d.driverId, d.name, lt.minMilliseconds AS earliestLapTime FROM ( SELECT driverId, MIN(milliseconds) AS minMilliseconds FROM lapTimes GROUP BY driverId ) AS lt JOIN drivers d ON d.driverId = lt.driverId WHERE d.nationality = 'German' AND strftime('%Y', d.dob) BETWEEN 1980 AND 1990 ORDER BY earliestLapTime ASC LIMIT 3;
SELECT driverRef FROM drivers WHERE nationality = 'German' AND dob = (SELECT MIN(dob) FROM drivers WHERE nationality = 'German');
SELECT DISTINCT d.driverId, d.code FROM drivers d JOIN results r ON r.driverId = d.driverId JOIN lapTimes l ON l.raceId = r.raceId AND l.driverId = d.driverId WHERE DATE_PART('year', d.dob) = 1971 AND (l.time, l.milliseconds) = ( SELECT MIN(lt.time), MIN(lt.milliseconds) FROM lapTimes lt WHERE lt.raceId = l.raceId AND lt.driverId = l.driverId );
SELECT d.driverId, forename, surname FROM drivers d JOIN ( SELECT driverId, MAX(time) AS latest_time FROM lapTimes GROUP BY driverId ) lt ON d.driverId = lt.driverId WHERE nationality = 'Spanish' AND dob < '1982-01-01' ORDER BY latest_time DESC LIMIT 10;
SELECT race.year AS racing_year, MIN(result.fastestLapTime) AS fastest_lap_time FROM results AS result JOIN races AS race ON result.raceId = race.raceId WHERE result.fastestLapTime IS NOT NULL GROUP BY race.year ORDER BY race.year;
WITH MaxLapTime AS ( SELECT races.year, MAX(lapTimes.time) as max_time FROM lapTimes JOIN races ON lapTimes.raceId = races.raceId GROUP BY races.year ) SELECT year, max_time FROM MaxLapTime WHERE max_time = ( SELECT MAX(max_time) FROM MaxLapTime );
SELECT driverId, MIN(time) AS fastestTime FROM lap_times WHERE lap = 1 GROUP BY driverId ORDER BY fastestTime ASC LIMIT 5;
SELECT COUNT(*) FROM results JOIN races ON results.raceId = races.raceId WHERE races.raceId BETWEEN 50 AND 100 AND results.statusId = 2 AND results.time IS NOT NULL;
SELECT c.name AS CircuitName, COUNT(r.raceId) AS NumberOfRaces, c.location, c.lat, c.lng FROM circuits c JOIN races r ON c.circuitId = r.circuitId WHERE c.country = 'Austria' GROUP BY c.circuitId;
SELECT raceId, COUNT(*) AS finishers_count FROM results WHERE time IS NOT NULL GROUP BY raceId ORDER BY finishers_count DESC LIMIT 1;
SELECT drivers.driverRef, nationality, dob FROM qualifying JOIN drivers ON qualifying.driverId = drivers.driverId WHERE qualifying.raceId = 23 AND q2 IS NOT NULL;
SELECT r.date AS year, r.name AS race_name, r.time AS qualifying_time FROM races r JOIN qualifying q ON r.race_id = q.race_id WHERE q.driver_id = ( SELECT d.driver_id FROM drivers d WHERE d.dob = (SELECT MAX(dob) FROM drivers) ) ORDER BY r.date ASC, r.time ASC LIMIT 1;
SELECT COUNT(DISTINCT d.driverId) AS american_puncture_drivers FROM drivers d JOIN results r ON d.driverId = r.driverId JOIN status s ON r.statusId = s.statusId WHERE d.nationality = 'American' AND s.status = 'Puncture';
SELECT c.name AS ConstructorName, c.url AS IntroductionWebsite, SUM(cs.points) AS TotalPoints FROM constructors c JOIN constructorStandings cs ON c.constructorId = cs.constructorId WHERE c.nationality = 'Italian' GROUP BY c.constructorId HAVING SUM(cs.points) = ( SELECT MAX(total_points) FROM ( SELECT SUM(cs2.points) AS total_points, cs2.constructorId FROM constructorStandings cs2 JOIN constructors c2 ON cs2.constructorId = c2.constructorId WHERE c2.nationality = 'Italian' GROUP BY cs2.constructorId ) subquery )
SELECT c.url AS constructor_website FROM constructors c JOIN constructorResults cr ON c.constructorId = cr.constructorId GROUP BY c.constructorId ORDER BY COUNT(cr.raceId) DESC LIMIT 1;
SELECT lt.driverId, driverRef, forename, surname, time, milliseconds FROM lapTimes AS lt JOIN races AS r ON lt.raceId = r.raceId WHERE r.name = 'French Grand Prix' AND lt.lap = 3 ORDER BY milliseconds DESC;
SELECT raceId, milliseconds FROM lapTimes WHERE lap = 1 AND milliseconds = ( SELECT MIN(milliseconds) AS fastest FROM lapTimes WHERE lap = 1 ) ORDER BY milliseconds;
SELECT ROUND(AVG(CAST(result.fastestLapTime AS REAL)), 2) AS average_fastest_lap_time FROM races race JOIN results result ON race.raceId = result.raceId WHERE race.year = 2006 AND race.name LIKE '%United States Grand Prix%' AND result.position < 11 AND result.fastestLapTime IS NOT NULL;
SELECT d.forename, d.surname, AVG(CAST(ps.duration AS DECIMAL)) AS average_pit_stop_duration FROM pitStops ps JOIN drivers d ON ps.driverId = d.driverId WHERE d.nationality = 'German' AND YEAR(d.dob) BETWEEN 1980 AND 1985 GROUP BY d.driverId ORDER BY average_pit_stop_duration ASC LIMIT 3;
SELECT drivers.forename AS driver_forename, drivers.surname AS driver_surname, results.time AS finish_time FROM races JOIN circuits ON races.circuitId = circuits.circuitId JOIN results ON races.raceId = results.raceId JOIN drivers ON results.driverId = drivers.driverId WHERE races.year = 2008 AND circuits.country = 'Canada' AND results.position = 1;
SELECT c.constructorRef, c.url FROM constructors AS c JOIN results AS r ON c.constructorId = r.constructorId WHERE r.raceId = ( SELECT raceId FROM races WHERE year = 2009 AND name LIKE '%Singapore%' ) AND r.position = 1;
SELECT forename || ' ' || surname AS FullName, dob FROM drivers WHERE nationality = 'Austrian' AND year(dob) BETWEEN 1981 AND 1991;
SELECT (forename || ' ' || surname) AS fullName, url AS WikipediaPageLink, dob AS DateOfBirth FROM drivers WHERE nationality = 'German' AND year(dob) BETWEEN 1971 AND 1985 ORDER BY dob DESC;
SELECT location, country, lat, lng FROM circuits WHERE name = 'Hungaroring';
SELECT c.name AS constructor_name, SUM(cr.points) AS total_points, c.nationality FROM races r JOIN constructorResults cr ON r.raceId = cr.raceId JOIN constructors c ON cr.constructorId = c.constructorId WHERE r.year BETWEEN 1980 AND 2010 AND r.name = 'Monaco Grand Prix' GROUP BY r.raceId, cr.constructorId ORDER BY total_points DESC LIMIT 1;
SELECT AVG(points) AS average_points FROM results JOIN races ON results.raceId = races.raceId JOIN circuits ON races.circuitId = circuits.circuitId JOIN drivers ON results.driverId = drivers.driverId WHERE drivers.forename = 'Lewis' AND drivers.surname = 'Hamilton' AND circuits.name = 'Turkish Grand Prix';
SELECT AVG(yearly_races) AS annual_average FROM ( SELECT YEAR(date) AS year, COUNT(*) AS yearly_races FROM races WHERE date BETWEEN '2000-01-01' AND '2010-12-31' GROUP BY YEAR(date) ) subquery;
SELECT nationality, COUNT(*) as driver_count FROM drivers GROUP BY nationality ORDER BY driver_count DESC LIMIT 1;
SELECT COUNT(*) AS victories FROM results WHERE driverId = ( SELECT driverId FROM driverStandings WHERE position = 91 );
SELECT races.name AS raceName, r.fastestLapTime FROM races JOIN ( SELECT resultId, raceId, driverId, constructorId, grid, position, points, laps, time, milliseconds, fastestLap, rank, fastestLapTime, fastestLapSpeed, statusId FROM results ) AS min_lap_time ON races.raceId = min_lap_time.raceId WHERE min_lap_time.fastestLapTime IS NOT NULL;
SELECT c.name AS circuitName, COALESCE(c.location, '') || ' (' || c.country || ')' AS fullLocation FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.date = (SELECT MAX(r2.date) FROM races r2 WHERE r2.date != '0000-00-00')
SELECT drivers.forename || ' ' || drivers.surname AS full_name FROM races JOIN qualifying ON races.raceId = qualifying.raceId JOIN drivers ON qualifying.driverId = drivers.driverId WHERE races.year = 2008 AND races.round = 3 AND races.circuitId = ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) AND qualifying.q3 = ( SELECT MIN(q3) FROM qualifying WHERE raceId = races.raceId );
SELECT d.forename || ' ' || d.surname AS fullName, d.nationality, r.name AS firstRaceName FROM drivers d JOIN results res ON d.driverId = res.driverId JOIN races r ON res.raceId = r.raceId WHERE d.dob = ( SELECT MAX(d2.dob) FROM drivers d2 ) GROUP BY d.driverId HAVING MIN(r.date);
SELECT MAX(accident_count) AS highest_accidents FROM ( SELECT COUNT(r.resultId) AS accident_count, r.driverId FROM results r JOIN races rc ON r.raceId = rc.raceId WHERE rc.name = 'Canadian Grand Prix' AND r.statusId = 3 GROUP BY r.driverId ) AS driver_accidents;
SELECT COUNT(*) AS wins, forename, surname FROM results r JOIN drivers d ON r.driverId = d.driverId WHERE position=1 AND dob=(SELECT MIN(dob) FROM drivers) GROUP BY d.driverId;
SELECT MAX(duration) AS LongestPitStopDuration FROM pitStops;
SELECT MIN(milliseconds) AS fastest_lap_time FROM lapTimes;
SELECT MAX(milliseconds) AS LongestPitStopTime FROM pitStops WHERE driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' ) GROUP BY raceId, driverId, stop;
SELECT lap FROM pitStops WHERE raceId = [race_id_of_2011_australian_grand_prix] AND driverId = [lewis_hamilton_driver_id];
SELECT p.driverId, p.duration, p.milliseconds FROM pitStops AS p JOIN races AS r ON p.raceId = r.raceId WHERE r.year = 2011 AND r.date = '2011-03-27';
SELECT MIN(lt.time) AS fastestLapTime FROM lapTimes lt JOIN drivers d ON lt.driverId = d.driverId WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton';
SELECT drivers.forename || ' ' || drivers.surname AS fullName, lapTimes.time FROM lapTimes JOIN drivers ON lapTimes.driverId = drivers.driverId WHERE lapTimes.time = ( SELECT MIN(time) FROM lapTimes WHERE time LIKE '%:SS.mmm' OR time LIKE ':%:SS.mmm' ) ORDER BY lapTimes.time ASC, drivers.forename, drivers.surname LIMIT 20;
SELECT lt.position FROM lapTimes lt WHERE lt.driverId = ( SELECT d.driverId FROM drivers d WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' ) AND lt.milliseconds = ( SELECT MIN(lt2.milliseconds) FROM lapTimes lt2 WHERE lt2.driverId = ( SELECT d.driverId FROM drivers d WHERE d.forename = 'Lewis' AND d.surname = 'Hamilton' ) );
SELECT MIN(time) AS LapRecord FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId JOIN circuits c ON r.circuitId = c.circuitId WHERE c.name LIKE 'Austrian Grand Prix Circuit';
SELECT c.circuitId, c.name AS circuitName, c.country, MIN(l.time) AS fastestLapTime FROM circuits c JOIN lapTimes l ON c.circuitId = l.raceId WHERE c.country = 'Italy' GROUP BY c.circuitId HAVING COUNT(*) >= 1 ORDER BY c.circuitId;
WITH FastestLaps AS ( SELECT lt.raceId, lt.lap, MIN(lt.milliseconds) AS min_millis FROM lapTimes lt GROUP BY lt.raceId, lt.lap ) SELECT r.year AS year, r.round AS round_number, r.raceName AS race_name, rt.driverId, d.driverRef AS driver_name, MIN(fl.min_millis) AS fastest_lap_time FROM races r JOIN circuits c ON r.circuitId = c.circuitId JOIN FastestLaps fl ON r.raceId = fl.raceId JOIN results rt ON r.raceId = rt.raceId AND fl.min_millis = rt.milliseconds JOIN drivers d ON rt.driverId = d.driverId WHERE c.name = 'Austrian Grand Prix Circuit' GROUP BY r.year, r.round, r.raceName, rt.driverId, d.driverRef;
WITH FastestLap AS ( SELECT lt.raceId, lt.driverId, lt.lap, lt.time AS lapTime, ROW_NUMBER() OVER (PARTITION BY lt.raceId ORDER BY lt.time ASC) AS rn FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId WHERE r.circuitName = 'Austrian Grand Prix Circuit' ) SELECT ps.duration FROM pitStops ps JOIN FastestLap fl ON ps.raceId = fl.raceId AND ps.driverId = fl.driverId WHERE fl.rn = 1;
SELECT DISTINCT c.lat, c.lng FROM results AS r JOIN circuits AS c ON r.raceId = c.circuitId WHERE r.time = '01:29.488';
SELECT AVG(milliseconds) AS average_pit_stop_time FROM pitStops WHERE driverId = ( SELECT driverId FROM drivers WHERE forename = 'Lewis' AND surname = 'Hamilton' );
SELECT AVG(lt.milliseconds) AS average_lap_time_ms FROM lapTimes lt JOIN races r ON lt.raceId = r.raceId JOIN circuits c ON r.circuitId = c.circuitId WHERE c.country = 'Italy';
SELECT player_api_id FROM Player WHERE overall_rating = ( SELECT MAX(overall_rating) FROM Player ) LIMIT 1;
SELECT player_name, MAX(height) AS tallest_height FROM Player;
SELECT preferred_foot FROM Player WHERE potential = (SELECT MIN(potential) FROM Player);
SELECT COUNT(DISTINCT player_api_id) AS NumberOfPlayers FROM Player_Attributes WHERE overall_rating >= 60 AND overall_rating < 65 AND defensive_work_rate = 'low';
WITH PlayerCrossingValues AS ( SELECT home_player_1 AS player_id, home_player_stat_1 AS crossing_value FROM Player_XY UNION ALL SELECT home_player_2, home_player_stat_2 FROM Player_XY UNION ALL SELECT home_player_3, home_player_stat_3 FROM Player_XY UNION ALL SELECT home_player_4, home_player_stat_4 FROM Player_XY UNION ALL SELECT home_player_5, home_player_stat_5 FROM Player_XY UNION ALL SELECT home_player_6, home_player_stat_6 FROM Player_XY UNION ALL SELECT home_player_7, home_player_stat_7 FROM Player_XY UNION ALL SELECT home_player_8, home_player_stat_8 FROM Player_XY UNION ALL SELECT home_player_9, home_player_stat_9 FROM Player_XY UNION ALL SELECT home_player_10, home_player_stat_10 FROM Player_XY UNION ALL SELECT home_player_11, home_player_stat_11 FROM Player_XY UNION ALL SELECT away_player_1, away_player_stat_1 FROM Player_XY UNION ALL SELECT away_player_2, away_player_stat_2 FROM Player_XY UNION ALL SELECT away_player_3, away_player_stat_3 FROM Player_XY UNION ALL SELECT away_player_4, away_player_stat_4 FROM Player_XY UNION ALL SELECT away_player_5, away_player_stat_5 FROM Player_XY UNION ALL SELECT away_player_6, away_player_stat_6 FROM Player_XY UNION ALL SELECT away_player_7, away_player_stat_7 FROM Player_XY UNION ALL SELECT away_player_8, away_player_stat_8 FROM Player_XY UNION ALL SELECT away_player_9, away_player_stat_9 FROM Player_XY UNION ALL SELECT away_player_10, away_player_stat_10 FROM Player_XY UNION ALL SELECT away_player_11, away_player_stat_11 FROM Player_XY ) SELECT player_id, MAX(crossing_value) AS max_crossing_value FROM PlayerCrossingValues GROUP BY player_id ORDER BY max_crossing_value DESC LIMIT 5;
SELECT League.league_name, SUM(home_team_goal + away_team_goal) AS total_goals FROM Match JOIN League ON Match.league_id = League.id -- This line assumes a join column exists in Match WHERE season = '2015/2016' GROUP BY League.league_name ORDER BY total_goals DESC LIMIT 1;
SELECT home_team_api_id AS TeamID, COUNT(*) AS NumberOfLosses FROM Match WHERE season = '2015/2016' AND home_team_goal < away_team_goal GROUP BY home_team_api_id ORDER BY NumberOfLosses ASC;
SELECT player_name, penalties FROM Player ORDER BY penalties DESC LIMIT 10;
SELECT away_team AS TeamName, COUNT(*) AS Wins FROM Match m JOIN League l ON m.league_id = l.league_id WHERE l.country = 'Scotland' AND l.league_name = 'Premier League' AND m.season = 2010 AND (m.result LIKE '%Away Win%' OR m.goals_for_away > m.goals_against_away) GROUP BY away_team ORDER BY Wins DESC;
SELECT
WITH DrawCounts AS ( SELECT league, COUNT(*) AS draw_count FROM Matches WHERE season = '2015/2016' AND home_team_goal = away_team_goal GROUP BY league ) SELECT league FROM DrawCounts ORDER BY draw_count DESC LIMIT 1;
SELECT p.player_name AS PlayerName, FLOOR((CURRENT_TIMESTAMP - CAST(p.birthday AS DATE)) / 365.25) AS Age FROM Player p JOIN Attributes a ON p.player_api_id = a.player_api_id WHERE a.sprint_speed >= 97 AND a.date BETWEEN '2013-01-01' AND '2015-12-31';
SELECT League, COUNT(*) AS NumberOfMatches FROM Matches WHERE League IS NOT NULL GROUP BY League ORDER BY NumberOfMatches DESC LIMIT 1;
SELECT (SUM(height) / COUNT(id)) AS average_height FROM Player WHERE birthday >= '1990-01-01' AND birthday < '1996-01-01';
SELECT p.player_api_id, p.overall_rating FROM player p WHERE substr(p.date, 1,4) = '2010' AND p.overall_rating > ( SELECT AVG(overall_rating) FROM player WHERE substr(date, 1,4) = '2010' );
SELECT team_fifa_api_id FROM team_stats WHERE buildUpPlaySpeed > 50 AND buildUpPlaySpeed < 60;
SELECT team_long_name FROM Team WHERE strftime('%Y', date) = '2012' AND buildUpPlayPassing > ( SELECT AVG(buildUpPlayPassing) FROM Team WHERE strftime('%Y', date) = '2012' );
SELECT (COUNT(CASE WHEN preferred_foot = 'left' AND YEAR(birthday) BETWEEN 1987 AND 1992 THEN player_fifa_api_id END) * 100.0) / COUNT(CASE WHEN YEAR(birthday) BETWEEN 1987 AND 1992 THEN player_fifa_api_id END) AS percentage FROM players;
SELECT l.league_name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals FROM match m JOIN team t ON m.home_team_api_id = t.team_api_id JOIN league l ON t.league_id = l.league_id GROUP BY l.league_name ORDER BY total_goals ASC LIMIT 5;
SELECT (SUM(ps.long_shots) / COUNT(p.player_api_id)) AS average_long_shots FROM Player p JOIN Player_Statics ps ON p.player_api_id = ps.player_api_id WHERE p.player_name = 'Ahmed Samir Farag';
SELECT p.name AS PlayerName, (SUM(ps.heading_accuracy) / COUNT(ps.player_fifa_api_id)) AS AverageHeadingAccuracy FROM Player p JOIN Player_Stats ps ON p.player_fifa_api_id = ps.player_fifa_api_id WHERE p.height > 180 GROUP BY ps.player_fifa_api_id ORDER BY AverageHeadingAccuracy DESC LIMIT 10;
WITH FilteredMatches AS ( SELECT date, buildUpPlayDribblingClass, chanceCreationPassing, homeTeamId, awayTeamId FROM Matches WHERE date >= '2014-01-01' AND date <= '2014-01-31' ), NormalClassMatches AS ( SELECT date, buildUpPlayDribblingClass, chanceCreationPassing, homeTeamId, awayTeamId FROM FilteredMatches WHERE buildUpPlayDribblingClass = 'Normal' ) SELECT team_id, AVG(chance_creation_passing) AS avg_chance_creation_passing FROM ( SELECT homeTeamId AS team_id, chanceCreationPassing AS chance_creation_passing FROM NormalClassMatches UNION ALL SELECT awayTeamId AS team_id, chanceCreationPassing AS chance_creation_passing FROM NormalClassMatches ) AS CombinedTeams GROUP BY team_id HAVING COUNT(*) >= 1 -- Ensure the team has at least one match in the period ORDER BY avg_chance_creation_passing DESC;
SELECT L.name AS League, AVG(home_team_goal) AS Average_Home_Goals, AVG(away_team_goal) AS Average_Away_Goals FROM Match M JOIN Team T ON M.home_team_api_id = T.team_api_id JOIN League L ON T.league_api_id = L.league_api_id WHERE M.season = '2009/2010' GROUP BY L.name HAVING AVG(home_team_goal) > AVG(away_team_goal);
SELECT team_short_name FROM team WHERE team_long_name = 'Queens Park Rangers';
SELECT * FROM Player WHERE substr(birthday, 1, 7) = '1970-10';
SELECT attacking_work_rate FROM Player WHERE name = 'Franco Zennaro';
SELECT buildUpPlayPositioningClass, COUNT(*) AS Count FROM Player WHERE Team = 'ADO Den Haag' GROUP BY buildUpPlayPositioningClass;
SELECT heading_accuracy FROM Player_Statistics WHERE player_name = 'Francois Affolter' AND date = '2014-09-18 00:00:00';
SELECT overall_rating FROM player_ratings WHERE strftime('%Y', date) = '2011' AND player_id = ( SELECT id FROM Player WHERE name = 'Gabriel Tamas' );
SELECT COUNT(*) AS NumberOfMatches FROM match m JOIN league l ON m.league_id = l.id WHERE l.name = 'Scotland Premier League';
SELECT preferred_foot FROM Player WHERE birthdate = (SELECT MAX(birthdate) FROM Player);
SELECT p.player_name AS Player, pa.potential AS Potential FROM Player p INNER JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE pa.potential = ( SELECT MAX(pa2.potential) FROM Player_Attributes pa2 );
SELECT COUNT(*) FROM Player WHERE weight < 130 AND preferred_foot = 'left';
SELECT team_short_name FROM team_info WHERE chanceCreationPassingClass = 'Risky';
SELECT pa.defensive_work_rate FROM Player_Attributes pa JOIN Player p ON pa.player_api_id = p.player_api_id WHERE p.name = 'David Wilson';
SELECT p.birthday AS highest_overall_rating_player_birthday FROM Player p JOIN ( SELECT ps.player_api_id FROM Player_Statistics ps WHERE ps.overall_rating = (SELECT MAX(ps2.overall_rating) FROM Player_Statistics ps2) ) sub ON p.player_api_id = sub.player_api_id;
SELECT name FROM League WHERE country = 'Netherlands';
SELECT AVG(home_team_goal) AS average_home_goals FROM Match JOIN League ON Match.league_id = League.id WHERE League.name = 'Poland' AND Match.season = '2010/2011';
WITH Tallest AS ( SELECT p.player_api_id, MAX(p.height) as max_height FROM Player p ), Shortest AS ( SELECT p.player_api_id, MIN(p.height) as min_height FROM Player p ) SELECT (SELECT AVG(pf.finishing) FROM Player_Finishing pf WHERE pf.player_api_id = Tallest.player_api_id) AS tallest_avg_finishing, (SELECT AVG(pf.finishing) FROM Player_Finishing pf WHERE pf.player_api_id = Shortest.player_api_id) AS shortest_avg_finishing FROM Tallest, Shortest;
SELECT name FROM Player WHERE height > 180;
SELECT COUNT(*) FROM Player WHERE strftime('%Y', birthday) > '1990';
SELECT COUNT(*) AS Adam_Players_Over_170 FROM Player WHERE first_name = 'Adam' AND weight > 170;
SELECT p.name AS player_name, MAX(ps.overall_rating) AS highest_rating FROM Player p JOIN Player_Statistics ps ON p.player_api_id = ps.player_api_id WHERE strftime('%Y', ps.date) BETWEEN '2008' AND '2010' AND ps.overall_rating > 80 GROUP BY ps.player_api_id;
SELECT potential FROM Player_Attributes WHERE name = 'Aaron Doran';
SELECT * FROM Player WHERE preferred_foot = 'left';
SELECT DISTINCT team_long_name FROM Team WHERE buildUpPlaySpeedClass = 'Fast';
-- Note: This query assumes the existence of a Team table with relevant columns. SELECT buildUpPlayPassingClass FROM Team WHERE team_short_name = 'CLB';
SELECT team_short_name FROM Team JOIN Team_Stats ON Team.team_api_id = Team_Stats.team_api_id WHERE buildUpPlayPassing > 70;
SELECT AVG(t2.overall_rating) AS average_overall_rating FROM ( SELECT t3.home_player_1, t3.home_player_2, ..., t3.away_player_1, t3.away_player_2, ... FROM Matches t3 WHERE strftime('%Y', date) BETWEEN '2010' AND '2015' ) AS match_players JOIN Players t1 ON match_players.player_api_id = t1.player_api_id JOIN Player_Attributes t2 ON t1.player_api_id = t2.player_api_id WHERE t2.height > 170;
SELECT * FROM Player WHERE height = (SELECT MIN(height) FROM Player);
SELECT country FROM League WHERE name = 'Italy Serie A';
SELECT team_short_name FROM Team_Attributes WHERE buildUpPlaySpeed = 31 AND buildUpPlayDribbling = 53 AND buildUpPlayPassing = 32;
SELECT player_api_id FROM Player WHERE player_name = 'Aaron Doran';
SELECT COUNT(*) FROM Match m JOIN League l ON m.league_id = l.id WHERE l.name = 'Germany 1. Bundesliga' AND strftime('%Y-%m', date) BETWEEN '2008-08' AND '2008-10';
SELECT t.team_short_name AS Short_Name FROM team AS t JOIN match AS m ON t.id = m.home_team_id WHERE m.home_team_goal = 10;
SELECT player_api_id, balance FROM Player WHERE potential = 61 AND balance = (SELECT MAX(balance) FROM Player WHERE potential = 61);
SELECT (SUM(CASE WHEN player_name = 'Abdou Diallo' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'Abdou Diallo' THEN id ELSE NULL END)) AS avg_abdou, (SUM(CASE WHEN player_name = 'Aaron Appindangoye' THEN ball_control ELSE 0 END) / COUNT(CASE WHEN player_name = 'Aaron Appindangoye' THEN id ELSE NULL END)) AS avg_aaron, (avg_abdou - avg_aaron) AS difference FROM Player_Stats;
SELECT team_long_name FROM team WHERE team_short_name = 'GEN';
SELECT name, dob FROM Player WHERE name IN ('Aaron Lennon', 'Abdelaziz Barrada');
SELECT player_api_id, MAX(height) AS tallest_height FROM Player;
SELECT COUNT(*) FROM Player_Attributes WHERE preferred_foot = 'left' AND attacking_work_rate = 'low';
SELECT country FROM League WHERE name = 'Belgium Jupiler League';
SELECT l.name AS LeagueName FROM League l JOIN Country c ON l.country_id = c.country_id WHERE c.name = 'Germany';
SELECT MAX(overall_rating) AS strongest_overall FROM Player;
SELECT COUNT(DISTINCT player_api_id) AS NumberOfPlayers FROM Player WHERE strftime('%Y', birthday) < '1986' AND defensive_work_rate = 'high';
SELECT player_api_id AS Player, crossing AS Crossing_Value FROM Player WHERE player_api_id IN ( SELECT player_api_id FROM Player WHERE name = 'Alexis', SELECT player_api_id FROM Player WHERE name = 'Ariel Borysiuk', SELECT player_api_id FROM Player WHERE name = 'Arouna Kone' );
SELECT p.player_name, pa.heading_accuracy FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.player_name = 'Ariel Borysiuk';
SELECT COUNT(*) FROM Player P INNER JOIN Player_Stats PS ON P.player_api_id = PS.player_api_id WHERE P.height > 180 AND PS.volleys > 70;
SELECT p.name FROM Player p JOIN Player_Stats ps ON p.player_api_id = ps.player_api_id WHERE ps.volleys > 70 AND ps.dribbling > 70;
SELECT COUNT(*) AS NumberOfMatches FROM Match m JOIN Country c ON m.country_id = c.id -- Assuming 'country_id' exists in Match and references Country's 'id' WHERE c.name = 'Belgium' AND m.season = '2008/2009';
SELECT px.long_passing, p.birth_date FROM Player AS p JOIN Player_Xref AS px ON p.player_api_id = px.player_api_id ORDER BY p.birth_date LIMIT 1;
SELECT COUNT(*) AS NumberOfMatches FROM Match m JOIN League l ON m.league_id = l.id WHERE SUBSTR(m.date, 1, 7) = 'April 2009' AND l.name = 'Belgium Jupiler League';
SELECT league, COUNT(*) AS match_count FROM match WHERE season = '2008/2009' GROUP BY league ORDER BY match_count DESC;
SELECT AVG(overall_rating) AS average_overall_rating FROM Player_Statistics WHERE strftime('%Y', birthday) < '1986';
SELECT ((Ariel_Borysiuk.overall_rating - Paulin_Puel.overall_rating) / Paulin_Puel.overall_rating) * 100 AS percentage_higher FROM Player Ariel_Borysiuk JOIN Player Paulin_Puel ON Ariel_Borysiuk.player_name = 'Ariel Borysiuk' AND Paulin_Puel.player_name = 'Paulin Puel';
SELECT AVG(buildUpPlaySpeed) AS Average_Build_Up_Speed FROM Player WHERE team_long_name = 'Heart of Midlothian';
SELECT AVG(overall_rating) AS average_overall_rating FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.player_name = 'Pietro Marino';
SELECT SUM(crossing) AS total_crossing_score FROM T2 JOIN Player P ON T2.player_api_id = P.player_api_id WHERE P.player_name = 'Aaron Lennox';
SELECT MAX(mc.chanceCreationPassing) AS highest_chance_creation_passing, mc.chanceCreationPassingClass AS classification FROM Match m JOIN Team t ON m.home_team_id = t.team_id OR m.away_team_id = t.team_id WHERE t.team_long_name = 'Ajax';
SELECT preferred_foot FROM Player WHERE player_name = 'Abdou Diallo';
SELECT MAX(overall_rating) AS highest_overall_rating FROM Player WHERE player_name = 'Dorlan Pabon';
